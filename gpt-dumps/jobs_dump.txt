===== GPT DUMP GENERATED: 2025-11-10T06:46:40Z =====
===== DIRECTORY: app/Jobs =====

app/Jobs/IngestTickerPriceHistoryJob.php


===== FILE: app/Jobs/IngestTickerPriceHistoryJob.php =====

<?php

namespace App\Jobs;

use App\Models\Ticker;
use App\Models\JobBatch;
use App\Services\PolygonTickerPriceHistoryService;
use App\Services\BatchMonitorService;
use Illuminate\Bus\Batchable;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use Illuminate\Support\Facades\Log;
use Throwable;

class IngestTickerPriceHistoryJob implements ShouldQueue
{
    use Batchable, Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    public Ticker $ticker;
    public string $from;
    public string $to;

    public int $tries = 3;
    public int $backoff = 30;

    public function __construct(Ticker $ticker, string $from = '2019-01-01', ?string $to = null)
    {
        $this->ticker = $ticker;
        $this->from = $from;
        $this->to = $to ?? now()->toDateString();
    }

    public function handle(PolygonTickerPriceHistoryService $service): void
    {
        $symbol = $this->ticker->ticker ?? $this->ticker->symbol ?? 'UNKNOWN';
        $logger = Log::channel('ingest');

        try {
            $logger->info("ðŸš€ Ingesting price history for {$symbol} ({$this->from} â†’ {$this->to})");
            $service->fetchAndStore($this->ticker, $this->from, $this->to);

            if ($batch = $this->batch()) {
                if ($jobBatch = JobBatch::find($batch->id)) {
                    BatchMonitorService::decrementPending($jobBatch);
                }
            }

            $logger->info("âœ… Completed ingestion for {$symbol}");
        } catch (Throwable $e) {
            $logger->error("âŒ Error ingesting {$symbol}: " . $e->getMessage(), [
                'ticker_id' => $this->ticker->id,
                'trace' => $e->getTraceAsString(),
            ]);

            if ($batch = $this->batch()) {
                if ($jobBatch = JobBatch::find($batch->id)) {
                    BatchMonitorService::markFailed($jobBatch, $this->job?->uuid() ?? uniqid('job_', true));
                }
            }

            throw $e;
        }
    }

    public function tags(): array
    {
        return [
            'ticker:' . ($this->ticker->ticker ?? 'unknown'),
            'price-history',
        ];
    }
}app/Jobs/IngestTickerNewsJob.php


===== FILE: app/Jobs/IngestTickerNewsJob.php =====

<?php

namespace App\Jobs;

use App\Models\Ticker;
use App\Models\JobBatch;
use App\Services\PolygonTickerNewsService;
use App\Services\BatchMonitorService;
use Illuminate\Bus\Queueable;
use Illuminate\Bus\Batchable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use Illuminate\Support\Facades\Log;
use Throwable;

class IngestTickerNewsJob implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels, Batchable;

    public int $tickerId;
    public int $limit;

    public int $tries = 3;
    public int $backoff = 30;

    public function __construct(int $tickerId, int $limit = 50)
    {
        $this->tickerId = $tickerId;
        $this->limit = $limit;
    }

    public function handle(PolygonTickerNewsService $service): void
    {
        $ticker = Ticker::find($this->tickerId);

        if (! $ticker) {
            Log::warning("âš ï¸ Ticker not found for news ingestion: ID {$this->tickerId}");
            return;
        }

        try {
            $count = $service->fetchNewsForTicker($ticker->ticker, $this->limit);
            Log::channel('ingest')->info("ðŸ“° Ingested {$count} news items for {$ticker->ticker}");

            // Batch monitoring update
            if ($batch = $this->batch()) {
                if ($jobBatch = JobBatch::find($batch->id)) {
                    BatchMonitorService::decrementPending($jobBatch);
                }
            }
        } catch (Throwable $e) {
            Log::channel('ingest')->error("âŒ Failed news ingestion for {$ticker->ticker}: {$e->getMessage()}");

            if ($batch = $this->batch()) {
                if ($jobBatch = JobBatch::find($batch->id)) {
                    BatchMonitorService::markFailed(
                        $jobBatch,
                        $this->job?->uuid() ?? uniqid('job_', true)
                    );
                }
            }

            throw $e;
        }
    }

    public function tags(): array
    {
        return [
            'ticker:' . ($this->tickerId ?? 'unknown'),
            'news',
        ];
    }
}app/Jobs/IngestTickerOverviewJob.php


===== FILE: app/Jobs/IngestTickerOverviewJob.php =====

<?php

namespace App\Jobs;

use App\Services\PolygonTickerOverviewService;
use Illuminate\Bus\Batchable;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use Illuminate\Support\Facades\App;
use Illuminate\Support\Facades\Log;
use Throwable;

/**
 * Job: IngestTickerOverviewJob
 *
 * Processes a batch of ticker symbols by fetching their overview data
 * from Polygon.io and upserting into the local DB.
 *
 * Note: This job is dispatched in batches by PolygonTickerOverviewsIngest.
 * Each instance should only contain scalar ticker symbols (strings) to
 * ensure serialization into the database queue works properly.
 */
class IngestTickerOverviewJob implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels, Batchable;

    /**
     * @var array List of ticker symbols (strings only)
     */
    protected $tickers;

    /**
     * @param array $tickers Plain array of ticker symbols, e.g. ['AAPL','MSFT']
     */
    public function __construct(array $tickers)
    {
        // Convert possible Eloquent models or objects to strings for safe serialization
        $this->tickers = array_map(function ($t) {
            if (is_object($t) && isset($t->ticker)) {
                return $t->ticker;
            }
            return (string) $t;
        }, $tickers);
    }

    /**
     * Handle the job.
     */
    public function handle(): void
    {
        $service = App::make(PolygonTickerOverviewService::class);
        $batchId = $this->batchId ?? 'n/a';
        $total = count($this->tickers);

        Log::channel('ingest')->info("ðŸš€ Processing ticker overview batch", [
            'batch_id' => $batchId,
            'total_tickers' => $total,
            'tickers_sample' => array_slice($this->tickers, 0, 5),
        ]);

        $processed = $succeeded = $failed = 0;

        foreach ($this->tickers as $ticker) {
            try {
                $service->fetchAndUpsertOverview($ticker);
                $succeeded++;
            } catch (Throwable $e) {
                $failed++;
                Log::channel('ingest')->error("âŒ Failed to process ticker overview", [
                    'ticker' => $ticker,
                    'batch_id' => $batchId,
                    'error' => $e->getMessage(),
                ]);
            }

            $processed++;
            if ($processed % 50 === 0 || $processed === $total) {
                Log::channel('ingest')->info("ðŸ“Š Batch progress", [
                    'batch_id' => $batchId,
                    'processed' => $processed,
                    'succeeded' => $succeeded,
                    'failed' => $failed,
                ]);
            }
        }

        Log::channel('ingest')->info("âœ… Batch complete", [
            'batch_id' => $batchId,
            'processed' => $processed,
            'succeeded' => $succeeded,
            'failed' => $failed,
        ]);
    }
}app/Jobs/IngestTickerIndicatorsJob.php


===== FILE: app/Jobs/IngestTickerIndicatorsJob.php =====

<?php

namespace App\Jobs;

use App\Models\Ticker;
use App\Services\PolygonIndicatorsService;
use Illuminate\Bus\Queueable;
use Illuminate\Bus\Batchable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use Illuminate\Support\Facades\Log;
use Throwable;

/**
 * Class IngestTickerIndicatorsJob
 *
 * A queued job that ingests raw technical indicator data
 * from the Polygon.io API for one or more tickers.
 *
 * Overview:
 * - Each job processes a batch of ticker IDs for specific indicators.
 * - It invokes the PolygonIndicatorsService for each ticker individually.
 * - Supports execution as part of distributed batches (Bus::batch()).
 *
 * Example usage:
 *   Bus::batch([
 *       new IngestTickerIndicatorsJob([1, 2, 3], ['sma_20','ema_50'])
 *   ])->dispatch();
 *
 * Design notes:
 * - All network I/O is isolated in the service layer.
 * - This job is network-bound, so concurrency can be high.
 * - Logging is routed to the 'ingest' channel for consistency.
 */
class IngestTickerIndicatorsJob implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels, Batchable;

    /** @var array<int> */
    protected array $tickerIds;

    /** @var array<string> */
    protected array $indicators;

    /** @var array{from?:string,to?:string} */
    protected array $range;

    /** @var int Maximum retry attempts */
    public int $tries = 3;

    /** @var int Seconds to wait before retrying */
    public int $backoff = 30;

    /**
     * @param array<int> $tickerIds
     * @param array<string> $indicators
     * @param array{from?:string,to?:string} $range
     */
    public function __construct(array $tickerIds = [], array $indicators = [], array $range = [])
    {
        // Defensive initialization ensures non-null before serialization
        $this->tickerIds  = $tickerIds ?: [];
        $this->indicators = $indicators ?: [];
        $this->range      = $range ?: [];
    }

    /**
     * Execute the ingestion job for all tickers in this batch.
     */
    public function handle(PolygonIndicatorsService $service): void
    {
        // Batch safety check â€” avoids "pendingJobs on null" errors
        if (method_exists($this, 'batch') && $this->batch()?->cancelled()) {
            Log::channel('ingest')->warning('â­ï¸ Skipping IngestTickerIndicatorsJob because the batch was cancelled or missing.', [
                'class' => static::class,
                'ticker_ids' => $this->tickerIds,
            ]);
            return;
        }

        // Defensive reinitialization after unserialization
        $tickerIds  = $this->tickerIds ?? [];
        $indicators = $this->indicators ?? [];
        $range      = $this->range ?? [];

        // Job start log marker
        Log::channel('ingest')->info('ðŸš€ Starting IngestTickerIndicatorsJob', [
            'ticker_count' => count($tickerIds),
            'indicators' => $indicators,
            'range' => $range,
            'batch_id' => $this->batchId ?? null,
        ]);

        // Fetch all tickers by ID
        $tickers = Ticker::whereIn('id', $tickerIds)->get(['id', 'ticker']);

        foreach ($tickers as $ticker) {
            $symbol = $ticker->ticker;

            // Begin ticker-level ingestion
            Log::channel('ingest')->info("ðŸŒ Fetching indicators from Polygon", [
                'ticker' => $symbol,
                'indicators' => $indicators,
                'range' => $range,
            ]);

            try {
                $service->fetchIndicators($symbol, $indicators, $range);

                // Success marker for this ticker
                Log::channel('ingest')->info("âœ… Polygon indicators ingested successfully", [
                    'ticker' => $symbol,
                    'ticker_id' => $ticker->id,
                    'indicators' => $indicators,
                ]);
            } catch (Throwable $e) {
                // âŒ Handle any failures gracefully with detailed logging
                Log::channel('ingest')->error("âŒ Polygon indicator ingestion failed", [
                    'ticker' => $symbol,
                    'ticker_id' => $ticker->id,
                    'indicators' => $indicators,
                    'message' => $e->getMessage(),
                    'trace' => substr($e->getTraceAsString(), 0, 800),
                ]);

                // Rethrow to mark the job failed for Laravel's retry handling
                throw $e;
            }
        }

        // Job complete marker
        Log::channel('ingest')->info("ðŸ IngestTickerIndicatorsJob finished successfully", [
            'batch_id' => $this->batchId ?? null,
            'tickers_processed' => count($tickerIds),
            'indicators' => $indicators,
        ]);
    }

    /**
     * Tags for Laravel Horizon monitoring / job grouping.
     */
    public function tags(): array
    {
        return [
            'ingest',
            'polygon',
            'resolution:1d',
            'batch:' . ($this->batchId ?? 'none'),
            'tickers:' . implode(',', $this->tickerIds),
        ];
    }
}app/Jobs/RunTickerAnalysis.php


===== FILE: app/Jobs/RunTickerAnalysis.php =====

<?php

namespace App\Jobs;

use App\Models\TickerAnalysis;
use App\Services\LLMProviderFactory;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use Illuminate\Support\Facades\Log;
use Throwable;
use RuntimeException;

class RunTickerAnalysis implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    public TickerAnalysis $analysis;

    /**
     * Number of times the job may be attempted.
     */
    public int $tries = 3;

    /**
     * Progressive backoff between retries (in seconds).
     */
    public function backoff(): array
    {
        return [60, 120, 300]; // 1 min, 2 min, 5 min
    }

    /**
     * Create a new job instance.
     */
    public function __construct(TickerAnalysis $analysis)
    {
        $this->analysis = $analysis;
    }

    /**
     * Execute the job.
     */
    public function handle(): void
    {
        $this->analysis->update(['status' => 'running']);
        $promptTemplate = str_replace(env('PROMPT_TICKER_REPLACE_STRING'), $this->analysis->ticker, config('prompts.analysis'));

        try {
            $provider = LLMProviderFactory::make($this->analysis->provider);
            $raw = $provider->analyze($this->analysis->ticker, $promptTemplate);

            // Detect rate limit responses (OpenAI, Gemini, etc.)
            if (
                isset($raw['error']['code']) &&
                str_contains(strtolower($raw['error']['code']), 'rate_limit')
            ) {
                Log::warning("Rate limit hit for {$this->analysis->provider}, retrying later.");
                throw new RuntimeException('Rate limit exceeded, will retry.');
            }

            Log::debug('LLM raw response', [
                'provider' => $this->analysis->provider,
                'ticker'   => $this->analysis->ticker,
                'raw'      => $raw,
            ]);

            /**
             * Handle multiple possible API response shapes.
             */
            $content =
                $raw['content']
                ?? ($raw['output'][0]['content'][0]['text'] ?? '')
                ?? ($raw['choices'][0]['message']['content'] ?? '')
                ?? ($raw['candidates'][0]['content']['parts'][0]['text'] ?? '')
                ?? '';

            if (empty(trim($content))) {
                throw new RuntimeException('Provider returned empty content.');
            }

            // Attempt structured extraction (safe)
            $structured = [];
            try {
                $structured = $provider->extractStructuredFromText($content) ?? [];
            } catch (Throwable $e) {
                Log::warning("Failed to extract structured data for {$this->analysis->ticker}: {$e->getMessage()}");
            }

            $summary = mb_substr(strip_tags($content), 0, 300);

            $this->analysis->update([
                'response_raw' => $raw,
                'summary'      => $summary,
                'structured'   => $structured,
                'status'       => 'completed',
                'completed_at' => now(),
            ]);

            // Cache results for 6 hours
            cache()->put(
                "ticker_analysis:{$this->analysis->ticker}:{$this->analysis->provider}",
                [
                    'analysis'   => $summary,
                    'structured' => $structured,
                    'model'      => $this->analysis->model,
                ],
                now()->addHours(6)
            );

            Log::info("Ticker analysis completed for {$this->analysis->ticker} ({$this->analysis->provider})");
        } catch (Throwable $e) {
            Log::error("Ticker analysis failed for {$this->analysis->ticker}: {$e->getMessage()}");

            $this->analysis->update([
                'status'       => 'failed',
                'response_raw' => ['error' => $e->getMessage()],
            ]);

            // Let Laravel handle backoff & retry automatically
            throw $e;
        } finally {
            // Safety: ensure status consistency
            if (!in_array($this->analysis->status, ['completed', 'failed'], true)) {
                $this->analysis->update(['status' => 'unknown']);
            }
        }
    }
}app/Jobs/ComputeTickerIndicatorsJob.php


===== FILE: app/Jobs/ComputeTickerIndicatorsJob.php =====

<?php

namespace App\Jobs;

use App\Services\Compute\FeaturePipeline;
use Illuminate\Bus\Batchable;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use Illuminate\Support\Facades\Log;

/**
 * ============================================================================
 *  ComputeTickerIndicatorsJob
 * ============================================================================
 *
 * ðŸ”§ Purpose:
 *   Queued job responsible for computing technical indicators
 *   (MACD, ATR, ADX, VWAP, etc.) for one or more tickers.
 *
 * ðŸ§  Design Overview:
 * ----------------------------------------------------------------------------
 *   â€¢ Delegates all compute logic to `FeaturePipeline`
 *   â€¢ Supports batched execution for thousands of tickers
 *   â€¢ Handles automatic persistence to:
 *       - `ticker_indicators` (core indicator storage)
 *       - `ticker_feature_snapshots` (optional)
 *   â€¢ Fully Horizon/queue-monitoring compatible
 *
 * ðŸ’¡ Usage Example:
 * ----------------------------------------------------------------------------
 *   // Standard dispatch for explicit tickers + indicators
 *   dispatch(new ComputeTickerIndicatorsJob(
 *       tickerIds: [1, 2, 3],
 *       indicators: ['macd', 'atr', 'adx', 'vwap'],
 *       range: ['from' => '2023-01-01', 'to' => '2023-12-31']
 *   ));
 *
 *   // Minimal dispatch (used by tickers:backfill-indicators)
 *   dispatch(new ComputeTickerIndicatorsJob([1, 2, 3], ['macd','atr']));
 *
 * ============================================================================
 */
class ComputeTickerIndicatorsJob implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels, Batchable;

    /** @var array<int> IDs of tickers to process. */
    public array $tickerIds;

    /** @var array<string> Indicator names to compute (e.g. ['macd','atr']). */
    public array $indicators;

    /** @var array{from?:string,to?:string} Optional date range. */
    public array $range;

    /** @var array Arbitrary parameter overrides. */
    public array $params;

    /** @var bool Whether to also generate feature snapshots after DB writes. */
    public bool $writeSnapshots;

    /** @var int Maximum retry attempts before job is marked as failed. */
    public int $tries = 3;

    /** @var int Maximum job runtime (seconds). */
    public int $timeout = 900; // extended slightly for larger batches

    /**
     * -------------------------------------------------------------------------
     *  Constructor
     * -------------------------------------------------------------------------
     *
     * @param  array<int>  $tickerIds
     * @param  array<string>  $indicators
     * @param  array{from?:string,to?:string}  $range
     * @param  array  $params
     * @param  bool  $writeSnapshots
     */
    public function __construct(
        array $tickerIds,
        array $indicators = [],
        array $range = [],
        array $params = [],
        bool $writeSnapshots = true
    ) {
        $this->tickerIds      = $tickerIds;
        $this->indicators     = $indicators ?: ['macd', 'atr', 'adx', 'vwap'];
        $this->range          = $range;
        $this->params         = $params;
        $this->writeSnapshots = $writeSnapshots;
    }

    /**
     * -------------------------------------------------------------------------
     *  Handle
     * -------------------------------------------------------------------------
     * Executes the indicator computation pipeline for each ticker.
     * Writes results to the database and optionally updates snapshots.
     * -------------------------------------------------------------------------
     */
    public function handle(FeaturePipeline $pipeline): void
    {
        // Safety: skip if batch has been cancelled.
        if (method_exists($this, 'batch') && $this->batch()?->cancelled()) {
            Log::channel('ingest')->warning('â­ï¸ Skipping ComputeTickerIndicatorsJob â€” batch cancelled.', [
                'tickers' => $this->tickerIds,
            ]);
            return;
        }

        Log::channel('ingest')->info('ðŸš€ Starting ComputeTickerIndicatorsJob', [
            'tickers'   => $this->tickerIds,
            'indicators'=> $this->indicators,
            'range'     => $this->range,
            'snapshots' => $this->writeSnapshots ? 'enabled' : 'disabled',
        ]);

        foreach ($this->tickerIds as $tickerId) {
            try {
                $result = $pipeline->runForTicker(
                    tickerId: $tickerId,
                    indicatorNames: $this->indicators,
                    range: $this->range,
                    params: $this->params,
                    writeCoreToDb: true,
                    buildSnapshots: $this->writeSnapshots,
                    primeCache: false
                );

                Log::channel('ingest')->info('âœ… Indicators computed successfully', [
                    'ticker_id'        => $tickerId,
                    'rows_inserted'    => $result['inserted'] ?? null,
                    'snapshots_written'=> $result['snapshots'] ?? null,
                ]);
            } catch (\Throwable $e) {
                Log::channel('ingest')->error('âŒ Indicator computation failed', [
                    'ticker_id' => $tickerId,
                    'message'   => $e->getMessage(),
                    'trace'     => substr($e->getTraceAsString(), 0, 800),
                ]);
                throw $e; // Allow Laravel retry/backoff
            }
        }

        Log::channel('ingest')->info('ðŸ ComputeTickerIndicatorsJob complete', [
            'tickers'    => $this->tickerIds,
            'indicators' => $this->indicators,
        ]);
    }

    /**
     * -------------------------------------------------------------------------
     *  Tags for Horizon / Job Monitoring
     * -------------------------------------------------------------------------
     */
    public function tags(): array
    {
        return [
            'compute',
            'tickers:' . implode(',', array_slice($this->tickerIds, 0, 5)) . (count($this->tickerIds) > 5 ? '...' : ''),
            'indicators:' . implode(',', $this->indicators),
            'snapshots:' . ($this->writeSnapshots ? 'on' : 'off'),
        ];
    }
}app/Jobs/BuildTickerSnapshotJob.php


===== FILE: app/Jobs/BuildTickerSnapshotJob.php =====

<?php

namespace App\Jobs;

use App\Services\Analytics\FeatureSnapshotBuilder;
use Illuminate\Bus\Batchable;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use Illuminate\Support\Facades\Log;

/**
 * Class BuildTickerSnapshotJob
 *
 * Queued job responsible for building (or previewing) JSON feature snapshots
 * for one or more tickers across a specified date range.
 *
 * Each snapshot represents a merged analytics vector containing:
 *   - Computed indicators from ticker_indicators
 *   - Derived analytics (Sharpe Ratio, Beta, Volatility, etc.)
 *   - Optional placeholders for sentiment/embeddings
 *
 * Designed for parallel execution under Laravelâ€™s Bus::batch()
 * via the TickersBuildSnapshots command.
 */
class BuildTickerSnapshotJob implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels, Batchable;

    /** @var array<int> List of ticker IDs to process. */
    public array $tickerIds;

    /** @var array{from?:string,to?:string} Optional date range for computation. */
    public array $range;

    /** @var array Optional runtime parameters (unused for now). */
    public array $params;

    /** @var bool Whether this job runs in dry-run preview mode. */
    public bool $preview;

    /** @var int Maximum retry attempts for transient failures. */
    public int $tries = 3;

    /** @var int Timeout (in seconds) per job execution. */
    public int $timeout = 600;

    /** @var int Backoff delay (seconds) before retrying failed jobs. */
    public int $backoff = 15;

    /**
     * @param array<int> $tickerIds
     * @param array{from?:string,to?:string} $range
     * @param array $params
     * @param bool $preview
     */
    public function __construct(array $tickerIds, array $range = [], array $params = [], bool $preview = false)
    {
        $this->tickerIds = $tickerIds;
        $this->range     = $range;
        $this->params    = $params;
        $this->preview   = $preview;
    }

    /**
     * Execute the job.
     *
     * For each ticker:
     *  - Loads indicator data
     *  - Computes derived metrics
     *  - Builds JSON feature snapshots
     *  - Writes or logs results depending on --preview mode
     */
    public function handle(FeatureSnapshotBuilder $builder): void
    {
        // ---------------------------------------------------------------------
        // 1ï¸âƒ£ Batch cancellation safety check
        // ---------------------------------------------------------------------
        if (method_exists($this, 'batch') && $this->batch()?->cancelled()) {
            Log::channel('ingest')->warning('â­ï¸ Skipping BuildTickerSnapshotJob â€” parent batch cancelled.', [
                'class'   => static::class,
                'tickers' => $this->tickerIds,
            ]);
            return;
        }

        // ---------------------------------------------------------------------
        // 2ï¸âƒ£ Job start log
        // ---------------------------------------------------------------------
        Log::channel('ingest')->info('ðŸš€ Starting BuildTickerSnapshotJob', [
            'tickers' => $this->tickerIds,
            'range'   => $this->range,
            'preview' => $this->preview,
            'job_id'  => $this->job?->getJobId() ?? null,
        ]);

        if ($this->preview) {
            Log::channel('ingest')->info('ðŸ’¡ Preview mode active â€” snapshots will be simulated only (no DB writes).', [
                'tickers' => $this->tickerIds,
            ]);
        }

        // ---------------------------------------------------------------------
        // 3ï¸âƒ£ Sequentially build snapshots for each ticker
        // ---------------------------------------------------------------------
        $totalSnapshots = 0;

        foreach ($this->tickerIds as $index => $tickerId) {
            $pos = $index + 1;
            $total = count($this->tickerIds);

            try {
                Log::channel('ingest')->info("â–¶ï¸ Building snapshot for ticker {$tickerId} ({$pos}/{$total})", [
                    'range'   => $this->range,
                    'preview' => $this->preview,
                ]);

                $res = $builder->buildForTicker($tickerId, $this->range, $this->params, $this->preview);
                $snapCount = $res['snapshots'] ?? 0;
                $totalSnapshots += $snapCount;

                Log::channel('ingest')->info('âœ… Snapshot built successfully', [
                    'ticker_id' => $tickerId,
                    'snapshots' => $snapCount,
                    'range'     => $this->range,
                    'preview'   => $this->preview,
                ]);
            } catch (\Throwable $e) {
                // Handle per-ticker failure safely; let Laravel retry if needed
                Log::channel('ingest')->error('âŒ Snapshot build failed', [
                    'ticker_id' => $tickerId,
                    'error'     => $e->getMessage(),
                    'trace'     => substr($e->getTraceAsString(), 0, 900),
                    'range'     => $this->range,
                    'preview'   => $this->preview,
                ]);

                // Allow retry by rethrowing exception
                throw $e;
            }
        }

        // ---------------------------------------------------------------------
        // 4ï¸âƒ£ Completion log
        // ---------------------------------------------------------------------
        Log::channel('ingest')->info('ðŸ BuildTickerSnapshotJob complete', [
            'tickers'        => $this->tickerIds,
            'snapshots_total'=> $totalSnapshots,
            'preview'        => $this->preview,
        ]);
    }

    /**
     * Tags for Laravel Horizon monitoring.
     */
    public function tags(): array
    {
        return [
            'snapshots',
            'tickers:' . implode(',', $this->tickerIds),
            'preview:' . ($this->preview ? 'true' : 'false'),
            'range:' . ($this->range['from'] ?? 'none') . '-' . ($this->range['to'] ?? 'none'),
        ];
    }
}app/Jobs/IngestTickerFundamentalsJob.php


===== FILE: app/Jobs/IngestTickerFundamentalsJob.php =====

<?php

namespace App\Jobs;

use App\Models\Ticker;
use App\Services\PolygonFundamentalsService;
use Illuminate\Bus\Queueable;
use Illuminate\Bus\Batchable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use Illuminate\Support\Facades\Log;
use Throwable;

class IngestTickerFundamentalsJob implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels, Batchable;

    public int $tickerId;
    public array $options;

    public int $tries = 3;
    public int $backoff = 30; // seconds

    /**
     * @param int   $tickerId
     * @param array $options  e.g. ['order' => 'desc', 'limit' => 100, 'timeframe' => 'quarterly']
     */
    public function __construct(int $tickerId, array $options = [])
    {
        $this->tickerId = $tickerId;
        $this->options  = $options;
    }

    public function handle(PolygonFundamentalsService $service): void
    {
        $ticker = Ticker::find($this->tickerId);

        if (! $ticker) {
            Log::channel('ingest')->warning("âš ï¸ Ticker not found for fundamentals ingestion", [
                'ticker_id' => $this->tickerId,
            ]);
            return;
        }

        $symbol = $ticker->ticker;
        Log::channel('ingest')->info("â–¶ï¸ Fundamentals job starting", [
            'symbol' => $symbol,
            'ticker_id' => $this->tickerId,
            'options' => $this->options,
        ]);

        try {
            // --- Phase 1: Begin API call
            Log::channel('ingest')->info("ðŸŒ Calling PolygonFundamentalsService::fetchAndStoreFundamentals()", [
                'symbol' => $symbol,
            ]);

            $count = $service->fetchAndStoreFundamentals($symbol, $this->options);

            // --- Phase 2: Validate response
            if (is_array($count)) {
                Log::channel('ingest')->warning("âš ï¸ Service returned array instead of count", [
                    'symbol' => $symbol,
                    'response_type' => gettype($count),
                    'keys' => array_keys($count),
                ]);
            }

            if (is_numeric($count)) {
                Log::channel('ingest')->info("âœ… Fundamentals service completed successfully", [
                    'symbol' => $symbol,
                    'records_inserted_or_updated' => (int) $count,
                ]);
            } else {
                Log::channel('ingest')->warning("âš ï¸ Fundamentals service returned unexpected result", [
                    'symbol' => $symbol,
                    'result_type' => gettype($count),
                    'value' => $count,
                ]);
            }

            Log::channel('ingest')->info("ðŸ Fundamentals job complete", [
                'symbol' => $symbol,
                'ticker_id' => $this->tickerId,
            ]);

        } catch (Throwable $e) {
            Log::channel('ingest')->error("âŒ Fundamentals job failed", [
                'symbol' => $symbol,
                'ticker_id' => $this->tickerId,
                'message' => $e->getMessage(),
                'trace' => substr($e->getTraceAsString(), 0, 1000), // limit trace length
            ]);
            throw $e; // Let the queue handle retries
        }
    }

    public function tags(): array
    {
        return [
            'fundamentals',
            'ticker:' . ($this->tickerId ?? 'unknown'),
        ];
    }
}
[EOF: app/Jobs]
