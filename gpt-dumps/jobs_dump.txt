===== GPT DUMP GENERATED: 2025-11-15T23:18:12Z =====
===== DIRECTORY: app/Jobs =====

app/Jobs/IngestTickerPriceHistoryJob.php


===== FILE: app/Jobs/IngestTickerPriceHistoryJob.php =====

<?php

namespace App\Jobs;

use App\Services\PolygonTickerPriceHistoryService;
use Illuminate\Bus\Batchable;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use Illuminate\Support\Carbon;
use Illuminate\Support\Facades\App;
use Illuminate\Support\Facades\Log;
use Throwable;

/**
 * ============================================================================
 *  IngestTickerPriceHistoryJob (v3.0.0)
 * ============================================================================
 *
 *  MULTI-TICKER + MULTI-RESOLUTION (1d + 1h) PRICE HISTORY INGESTION
 *
 *  âœ” Handles MANY tickers per job (100â€“500 depending on batch size)
 *  âœ” Auto-from per ticker using DB latest-t + redundancy
 *  âœ” Fetches BOTH daily + hourly bars in same job
 *  âœ” Bulk inserts via PolygonTickerPriceHistoryService
 *  âœ” Hourly retention purge (default: 168 hours)
 *  âœ” Ultra-safe logging & error isolation (ticker-level try/catch)
 *
 *  Payload Input:
 *      $tickers = [
 *         [id => 24, ticker => 'AAPL', type => 'cs'],
 *         [id => ...],
 *         ...
 *      ]
 *
 *  NOTE: No memory blow-up â€” each ticker is processed independently.
 * ============================================================================
 */
class IngestTickerPriceHistoryJob implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels, Batchable;

    /**
     * @var array<int, array{id:int,ticker:string,type:?string}>
     */
    protected array $tickers;

    protected string $resolutionMode; // "1d", "1h", or "both"
    protected string $globalFrom;
    protected string $toDate;

    protected int $windowDays;       // Daily auto-from lookback
    protected int $redundancyDays;   // Daily overlap
    protected int $redundancyHours;  // Hourly overlap
    protected int $retentionHours;   // Retention cutoff for 1h

    /**
     * @param array<int,array{id:int,ticker:string,type:?string}> $tickers
     */
    public function __construct(
        array $tickers,
        string $resolutionMode,
        string $globalFrom,
        string $toDate,
        int $windowDays,
        int $redundancyDays,
        int $redundancyHours,
        int $retentionHours
    ) {
        $this->tickers         = $tickers;
        $this->resolutionMode  = $resolutionMode;
        $this->globalFrom      = $globalFrom;
        $this->toDate          = $toDate;
        $this->windowDays      = $windowDays;
        $this->redundancyDays  = $redundancyDays;
        $this->redundancyHours = $redundancyHours;
        $this->retentionHours  = $retentionHours;
    }

    /**
     * Execute the multi-ticker job.
     */
    public function handle(): void
    {
        $service = App::make(PolygonTickerPriceHistoryService::class);
        $logger  = Log::channel('ingest');

        $batchId = $this->batchId ?? 'n/a';

        $logger->info("ðŸš€ Multi-ticker price-history batch started", [
            'batch_id'        => $batchId,
            'tickers_count'   => count($this->tickers),
            'resolution_mode' => $this->resolutionMode,
        ]);

        $processed  = 0;
        $succeeded  = 0;
        $failed     = 0;

        foreach ($this->tickers as $t) {
            $tickerId = $t['id'];
            $symbol   = $t['ticker'];

            try {
                $this->processOneTicker(
                    $service,
                    $symbol,
                    $tickerId
                );

                $succeeded++;
            } catch (Throwable $e) {
                $failed++;

                $logger->error('âŒ Failed ticker ingestion', [
                    'ticker'   => $symbol,
                    'ticker_id'=> $tickerId,
                    'batch_id' => $batchId,
                    'error'    => $e->getMessage(),
                    'trace'    => substr($e->getTraceAsString(), 0, 500),
                ]);
            }

            $processed++;

            if ($processed % 25 === 0 || $processed === count($this->tickers)) {
                $logger->info("ðŸ“Š Ingestion batch progress", [
                    'batch_id'  => $batchId,
                    'processed' => $processed,
                    'succeeded' => $succeeded,
                    'failed'    => $failed,
                ]);
            }
        }

        // Global hourly retention purge (only once per job)
        try {
            $cutoff = Carbon::now()->subHours($this->retentionHours);
            $deleted = $service->purgeOld1h($cutoff);

            $logger->info("ðŸ§¹ Hourly retention purge completed", [
                'batch_id'       => $batchId,
                'cutoff'         => $cutoff->toDateTimeString(),
                'deleted_rows'   => $deleted,
                'retentionHours' => $this->retentionHours,
            ]);
        } catch (Throwable $e) {
            $logger->error("âŒ 1h retention purge failed", [
                'batch_id' => $batchId,
                'error'    => $e->getMessage(),
            ]);
        }

        $logger->info("âœ… Multi-ticker batch complete", [
            'batch_id'  => $batchId,
            'processed' => $processed,
            'succeeded' => $succeeded,
            'failed'    => $failed,
        ]);
    }

    /**
     * Process a single ticker (1d + 1h resolution).
     */
    protected function processOneTicker(
        PolygonTickerPriceHistoryService $service,
        string $symbol,
        int $tickerId
    ): void {
        $logger = Log::channel('ingest');

        $logger->info("ðŸ“ˆ Processing ticker", [
            'symbol'    => $symbol,
            'ticker_id' => $tickerId,
        ]);

        $globalFrom = Carbon::parse($this->globalFrom);
        $toDate     = Carbon::parse($this->toDate)->endOfDay();

        // ---------------------------------------------------------------------
        // DAILY AUTO-FROM
        // ---------------------------------------------------------------------
        $latestDaily = $service->getLatestTimestamp($tickerId, '1d');
        $dailyFrom = $latestDaily
            ? Carbon::parse($latestDaily)->subDays($this->redundancyDays)
            : $globalFrom->copy();

        if ($dailyFrom->lt($globalFrom)) {
            $dailyFrom = $globalFrom->copy();
        }

        // Bound the auto-from window
        $minDaily = Carbon::now()->subDays($this->windowDays);
        if ($dailyFrom->lt($minDaily)) {
            $dailyFrom = $minDaily;
        }

        // ---------------------------------------------------------------------
        // HOURLY AUTO-FROM
        // ---------------------------------------------------------------------
        $latestHourly = $service->getLatestTimestamp($tickerId, '1h');
        $hourlyFrom = $latestHourly
            ? Carbon::parse($latestHourly)->subHours($this->redundancyHours)
            : Carbon::now()->subDays(7)->startOfDay(); // fallback: 7-day lookback

        // ---------------------------------------------------------------------
        // FETCH DAILY BARS
        // ---------------------------------------------------------------------
        if ($this->resolutionMode === '1d' || $this->resolutionMode === 'both') {
            $service->fetchAndStoreBars(
                $symbol,
                $tickerId,
                '1d',
                $dailyFrom,
                $toDate
            );
        }

        // ---------------------------------------------------------------------
        // FETCH HOURLY BARS
        // ---------------------------------------------------------------------
        if ($this->resolutionMode === '1h' || $this->resolutionMode === 'both') {
            $service->fetchAndStoreBars(
                $symbol,
                $tickerId,
                '1h',
                $hourlyFrom,
                $toDate
            );
        }

        $logger->info("âœ… Completed ticker", [
            'symbol'        => $symbol,
            'ticker_id'     => $tickerId,
            'daily_from'    => $dailyFrom->toDateString(),
            'hourly_from'   => $hourlyFrom->toDateTimeString(),
        ]);
    }
}app/Jobs/IngestTickerNewsJob.php


===== FILE: app/Jobs/IngestTickerNewsJob.php =====

<?php

namespace App\Jobs;

use App\Models\Ticker;
use App\Models\JobBatch;
use App\Services\PolygonTickerNewsService;
use App\Services\BatchMonitorService;
use Illuminate\Bus\Queueable;
use Illuminate\Bus\Batchable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use Illuminate\Support\Facades\Log;
use Throwable;

/**
 * ============================================================================
 *  IngestTickerNewsJob (v2.0 â€” Serialization-Safe Refactor)
 * ============================================================================
 *
 * â— WHAT THIS FIXES:
 *   â€¢ Removes ALL non-primitive members from the public job payload.
 *   â€¢ Prevents "Cannot assign NativeSerializableClosure..." failures.
 *   â€¢ Ensures the DB queue payload contains ONLY primitives.
 *
 * PURPOSE:
 *   Fetches & stores Polygon.io news items for a single ticker.
 *   This job is dispatched in large batches by PolygonTickerNewsIngest.
 *
 * SAFE PAYLOAD:
 *   - int $tickerId
 *   - int $limit
 * ============================================================================
 */
class IngestTickerNewsJob implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels, Batchable;

    /**
     * Strictly primitive-only properties (required for DB queue safety)
     */
    public int $tickerId;
    public int $limit;

    /**
     * Retry behavior
     */
    public int $tries = 3;
    public int $backoff = 30; // seconds

    /**
     * @param int $tickerId  The ID of the ticker (NOT a model instance)
     * @param int $limit     Max number of articles to pull (per API call cycle)
     */
    public function __construct(int $tickerId, int $limit = 50)
    {
        $this->tickerId = $tickerId;
        $this->limit    = $limit;
    }

    /**
     * Execute the job.
     */
    public function handle(PolygonTickerNewsService $service): void
    {
        // Lookup ticker safely inside the job (do NOT store model in payload)
        $ticker = Ticker::find($this->tickerId);

        if (! $ticker) {
            Log::channel('ingest')->warning("âš ï¸ News job: Ticker not found", [
                'ticker_id' => $this->tickerId,
            ]);
            return;
        }

        $symbol = $ticker->ticker;

        Log::channel('ingest')->info("ðŸ“° Starting news ingestion job", [
            'ticker_id' => $this->tickerId,
            'symbol'    => $symbol,
            'limit'     => $this->limit,
        ]);

        try {
            /**
             * Service returns: int $count OR array with details
             */
            $result = $service->fetchNewsForTicker($symbol, $this->limit);

            if (is_numeric($result)) {
                Log::channel('ingest')->info("âœ… News ingestion complete", [
                    'symbol'  => $symbol,
                    'count'   => (int) $result,
                ]);
            } else {
                Log::channel('ingest')->warning("âš ï¸ Unexpected news service result", [
                    'symbol' => $symbol,
                    'type'   => gettype($result),
                    'sample' => is_array($result) ? array_slice($result, 0, 3) : $result,
                ]);
            }

            // -----------------------------
            // BatchMonitorService integration
            // -----------------------------
            if ($batch = $this->batch()) {
                if ($jobBatch = JobBatch::find($batch->id)) {
                    BatchMonitorService::decrementPending($jobBatch);
                }
            }

        } catch (Throwable $e) {

            Log::channel('ingest')->error("âŒ News ingestion failed", [
                'symbol'    => $symbol,
                'ticker_id' => $this->tickerId,
                'message'   => $e->getMessage(),
                'trace'     => substr($e->getTraceAsString(), 0, 1000),
            ]);

            // Mark batch job failure
            if ($batch = $this->batch()) {
                if ($jobBatch = JobBatch::find($batch->id)) {
                    BatchMonitorService::markFailed(
                        $jobBatch,
                        $this->job?->uuid() ?? uniqid('news_', true)
                    );
                }
            }

            throw $e; // allow queue retries
        }
    }

    /**
     * Queue job tags (shown in Horizon/UIs)
     */
    public function tags(): array
    {
        return [
            'news',
            'ticker:' . $this->tickerId,
        ];
    }
}app/Jobs/IngestTickerOverviewJob.php


===== FILE: app/Jobs/IngestTickerOverviewJob.php =====

<?php

namespace App\Jobs;

use App\Services\PolygonTickerOverviewService;
use Illuminate\Bus\Batchable;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use Illuminate\Support\Facades\App;
use Illuminate\Support\Facades\Log;
use Throwable;

/**
 * ============================================================================
 *  IngestTickerOverviewJob  (v2.1 â€” Hardened & Time-Aware)
 * ============================================================================
 *
 *  âœ” Ensures all tickers are STRINGS before serialization
 *  âœ” Completely prevents "Array to string conversion" errors
 *  âœ” Safe JSON logging for debugging without breaking workers
 *  âœ” Validates Polygon response shape at runtime
 *  âœ” Ensures the service receives only scalar ticker symbols
 *  âœ” Fully compatible with database queue serialization
 *  âœ” Adds basic timing info to understand per-job runtime
 * ============================================================================
 */
class IngestTickerOverviewJob implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels, Batchable;

    /**
     * @var array<string> Guaranteed list of clean string tickers
     */
    protected array $tickers;

    /**
     * Maximum attempts for this job.
     *
     * (We keep this modest; flakey tickers will eventually give up.)
     */
    public int $tries = 3;

    /**
     * @param  array  $tickers  An array of raw items (strings, models, objects, etc.).
     *                          All values are normalized to simple strings here.
     */
    public function __construct(array $tickers)
    {
        $clean = [];

        foreach ($tickers as $t) {
            if (is_object($t) && isset($t->ticker)) {
                $clean[] = (string) $t->ticker;
            } elseif (is_string($t)) {
                $clean[] = $t;
            } elseif (is_scalar($t)) {
                $clean[] = (string) $t;
            } else {
                // â— Any non-scalar / non-string / non-model value is discarded to avoid crashes.
                Log::channel('ingest')->warning('âš ï¸ Dropping non-scalar ticker in job payload', [
                    'received_type' => gettype($t),
                    'value_preview' => is_array($t) ? array_slice($t, 0, 5) : $t,
                ]);
            }
        }

        $this->tickers = array_values($clean);
    }

    /**
     * Handle the job.
     */
    public function handle(): void
    {
        $service  = App::make(PolygonTickerOverviewService::class);
        $batchId  = $this->batchId ?? 'n/a';
        $total    = count($this->tickers);
        $started  = microtime(true);

        Log::channel('ingest')->info("ðŸš€ Starting ticker overview batch", [
            'batch_id' => $batchId,
            'count'    => $total,
            'sample'   => array_slice($this->tickers, 0, 5),
        ]);

        $processed = 0;
        $succeeded = 0;
        $failed    = 0;

        foreach ($this->tickers as $ticker) {
            // â›‘ Safety guard: ensure scalar string before service call
            if (! is_string($ticker) || trim($ticker) === '') {
                $failed++;
                Log::channel('ingest')->error("âŒ Invalid ticker value encountered", [
                    'batch_id'   => $batchId,
                    'ticker_raw' => $ticker,
                ]);
                $processed++;
                continue;
            }

            try {
                $result = $service->fetchAndUpsertOverview($ticker);

                // OPTIONAL: Validate service return shape to prevent upstream failures
                if (is_array($result) && isset($result['error'])) {
                    throw new \Exception("Polygon service reported error: " . json_encode($result['error']));
                }

                $succeeded++;
            } catch (Throwable $e) {
                $failed++;

                Log::channel('ingest')->error("âŒ Failed processing ticker overview", [
                    'ticker'   => $ticker,
                    'batch_id' => $batchId,
                    'error'    => $e->getMessage(),
                    'trace'    => substr($e->getTraceAsString(), 0, 300),
                ]);
            }

            $processed++;

            // Log progress every 50 tickers or at end
            if ($processed % 50 === 0 || $processed === $total) {
                Log::channel('ingest')->info("ðŸ“Š Batch progress", [
                    'batch_id'  => $batchId,
                    'processed' => $processed,
                    'succeeded' => $succeeded,
                    'failed'    => $failed,
                ]);
            }
        }

        $duration = microtime(true) - $started;

        Log::channel('ingest')->info("âœ… Overview batch complete", [
            'batch_id'  => $batchId,
            'processed' => $processed,
            'succeeded' => $succeeded,
            'failed'    => $failed,
            'duration_s'=> round($duration, 2),
        ]);
    }
}app/Jobs/IngestTickerIndicatorsJob.php


===== FILE: app/Jobs/IngestTickerIndicatorsJob.php =====

<?php

namespace App\Jobs;

use App\Models\Ticker;
use App\Services\PolygonIndicatorsService;
use Illuminate\Bus\Queueable;
use Illuminate\Bus\Batchable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use Illuminate\Support\Facades\Log;
use Throwable;

/**
 * Class IngestTickerIndicatorsJob
 *
 * A queued job that ingests raw technical indicator data
 * from the Polygon.io API for one or more tickers.
 *
 * Overview:
 * - Each job processes a batch of ticker IDs for specific indicators.
 * - It invokes the PolygonIndicatorsService for each ticker individually.
 * - Supports execution as part of distributed batches (Bus::batch()).
 *
 * Example usage:
 *   Bus::batch([
 *       new IngestTickerIndicatorsJob([1, 2, 3], ['sma_20','ema_50'])
 *   ])->dispatch();
 *
 * Design notes:
 * - All network I/O is isolated in the service layer.
 * - This job is network-bound, so concurrency can be high.
 * - Logging is routed to the 'ingest' channel for consistency.
 */
class IngestTickerIndicatorsJob implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels, Batchable;

    /** @var array<int> */
    protected array $tickerIds;

    /** @var array<string> */
    protected array $indicators;

    /** @var array{from?:string,to?:string} */
    protected array $range;

    /** @var int Maximum retry attempts */
    public int $tries = 3;

    /** @var int Seconds to wait before retrying */
    public int $backoff = 30;

    /**
     * @param array<int> $tickerIds
     * @param array<string> $indicators
     * @param array{from?:string,to?:string} $range
     */
    public function __construct(array $tickerIds = [], array $indicators = [], array $range = [])
    {
        // Defensive initialization ensures non-null before serialization
        $this->tickerIds  = $tickerIds ?: [];
        $this->indicators = $indicators ?: [];
        $this->range      = $range ?: [];
    }

    /**
     * Execute the ingestion job for all tickers in this batch.
     */
    public function handle(PolygonIndicatorsService $service): void
    {
        // Batch safety check â€” avoids "pendingJobs on null" errors
        if (method_exists($this, 'batch') && $this->batch()?->cancelled()) {
            Log::channel('ingest')->warning('â­ï¸ Skipping IngestTickerIndicatorsJob because the batch was cancelled or missing.', [
                'class' => static::class,
                'ticker_ids' => $this->tickerIds,
            ]);
            return;
        }

        // Defensive reinitialization after unserialization
        $tickerIds  = $this->tickerIds ?? [];
        $indicators = $this->indicators ?? [];
        $range      = $this->range ?? [];

        // Job start log marker
        Log::channel('ingest')->info('ðŸš€ Starting IngestTickerIndicatorsJob', [
            'ticker_count' => count($tickerIds),
            'indicators' => $indicators,
            'range' => $range,
            'batch_id' => $this->batchId ?? null,
        ]);

        // Fetch all tickers by ID
        $tickers = Ticker::whereIn('id', $tickerIds)->get(['id', 'ticker']);

        foreach ($tickers as $ticker) {
            $symbol = $ticker->ticker;

            // Begin ticker-level ingestion
            Log::channel('ingest')->info("ðŸŒ Fetching indicators from Polygon", [
                'ticker' => $symbol,
                'indicators' => $indicators,
                'range' => $range,
            ]);

            try {
                $service->fetchIndicators($symbol, $indicators, $range);

                // Success marker for this ticker
                Log::channel('ingest')->info("âœ… Polygon indicators ingested successfully", [
                    'ticker' => $symbol,
                    'ticker_id' => $ticker->id,
                    'indicators' => $indicators,
                ]);
            } catch (Throwable $e) {
                // âŒ Handle any failures gracefully with detailed logging
                Log::channel('ingest')->error("âŒ Polygon indicator ingestion failed", [
                    'ticker' => $symbol,
                    'ticker_id' => $ticker->id,
                    'indicators' => $indicators,
                    'message' => $e->getMessage(),
                    'trace' => substr($e->getTraceAsString(), 0, 800),
                ]);

                // Rethrow to mark the job failed for Laravel's retry handling
                throw $e;
            }
        }

        // Job complete marker
        Log::channel('ingest')->info("ðŸ IngestTickerIndicatorsJob finished successfully", [
            'batch_id' => $this->batchId ?? null,
            'tickers_processed' => count($tickerIds),
            'indicators' => $indicators,
        ]);
    }

    /**
     * Tags for Laravel Horizon monitoring / job grouping.
     */
    public function tags(): array
    {
        return [
            'ingest',
            'polygon',
            'resolution:1d',
            'batch:' . ($this->batchId ?? 'none'),
            'tickers:' . implode(',', $this->tickerIds),
        ];
    }
}app/Jobs/RunTickerAnalysis.php


===== FILE: app/Jobs/RunTickerAnalysis.php =====

<?php

namespace App\Jobs;

use App\Models\TickerAnalysis;
use App\Services\LLMProviderFactory;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use Illuminate\Support\Facades\Log;
use Throwable;
use RuntimeException;

class RunTickerAnalysis implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    public TickerAnalysis $analysis;

    /**
     * Number of times the job may be attempted.
     */
    public int $tries = 3;

    /**
     * Progressive backoff between retries (in seconds).
     */
    public function backoff(): array
    {
        return [60, 120, 300]; // 1 min, 2 min, 5 min
    }

    /**
     * Create a new job instance.
     */
    public function __construct(TickerAnalysis $analysis)
    {
        $this->analysis = $analysis;
    }

    /**
     * Execute the job.
     */
    public function handle(): void
    {
        $this->analysis->update(['status' => 'running']);
        $promptTemplate = str_replace(env('PROMPT_TICKER_REPLACE_STRING'), $this->analysis->ticker, config('prompts.analysis'));

        try {
            $provider = LLMProviderFactory::make($this->analysis->provider);
            $raw = $provider->analyze($this->analysis->ticker, $promptTemplate);

            // Detect rate limit responses (OpenAI, Gemini, etc.)
            if (
                isset($raw['error']['code']) &&
                str_contains(strtolower($raw['error']['code']), 'rate_limit')
            ) {
                Log::warning("Rate limit hit for {$this->analysis->provider}, retrying later.");
                throw new RuntimeException('Rate limit exceeded, will retry.');
            }

            Log::debug('LLM raw response', [
                'provider' => $this->analysis->provider,
                'ticker'   => $this->analysis->ticker,
                'raw'      => $raw,
            ]);

            /**
             * Handle multiple possible API response shapes.
             */
            $content =
                $raw['content']
                ?? ($raw['output'][0]['content'][0]['text'] ?? '')
                ?? ($raw['choices'][0]['message']['content'] ?? '')
                ?? ($raw['candidates'][0]['content']['parts'][0]['text'] ?? '')
                ?? '';

            if (empty(trim($content))) {
                throw new RuntimeException('Provider returned empty content.');
            }

            // Attempt structured extraction (safe)
            $structured = [];
            try {
                $structured = $provider->extractStructuredFromText($content) ?? [];
            } catch (Throwable $e) {
                Log::warning("Failed to extract structured data for {$this->analysis->ticker}: {$e->getMessage()}");
            }

            $summary = mb_substr(strip_tags($content), 0, 300);

            $this->analysis->update([
                'response_raw' => $raw,
                'summary'      => $summary,
                'structured'   => $structured,
                'status'       => 'completed',
                'completed_at' => now(),
            ]);

            // Cache results for 6 hours
            cache()->put(
                "ticker_analysis:{$this->analysis->ticker}:{$this->analysis->provider}",
                [
                    'analysis'   => $summary,
                    'structured' => $structured,
                    'model'      => $this->analysis->model,
                ],
                now()->addHours(6)
            );

            Log::info("Ticker analysis completed for {$this->analysis->ticker} ({$this->analysis->provider})");
        } catch (Throwable $e) {
            Log::error("Ticker analysis failed for {$this->analysis->ticker}: {$e->getMessage()}");

            $this->analysis->update([
                'status'       => 'failed',
                'response_raw' => ['error' => $e->getMessage()],
            ]);

            // Let Laravel handle backoff & retry automatically
            throw $e;
        } finally {
            // Safety: ensure status consistency
            if (!in_array($this->analysis->status, ['completed', 'failed'], true)) {
                $this->analysis->update(['status' => 'unknown']);
            }
        }
    }
}app/Jobs/ComputeTickerIndicatorsJob.php


===== FILE: app/Jobs/ComputeTickerIndicatorsJob.php =====

<?php

namespace App\Jobs;

use App\Services\Compute\FeaturePipeline;
use Illuminate\Bus\Batchable;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use Illuminate\Support\Facades\Log;

/**
 * ============================================================================
 *  ComputeTickerIndicatorsJob
 * ============================================================================
 *
 * ðŸ”§ Purpose:
 *   Queued job responsible for computing technical indicators
 *   (MACD, ATR, ADX, VWAP, etc.) for one or more tickers.
 *
 * ðŸ§  Design Overview:
 * ----------------------------------------------------------------------------
 *   â€¢ Delegates all compute logic to `FeaturePipeline`
 *   â€¢ Supports batched execution for thousands of tickers
 *   â€¢ Handles automatic persistence to:
 *       - `ticker_indicators` (core indicator storage)
 *       - `ticker_feature_snapshots` (optional)
 *   â€¢ Fully Horizon/queue-monitoring compatible
 *
 * ðŸ’¡ Usage Example:
 * ----------------------------------------------------------------------------
 *   // Standard dispatch for explicit tickers + indicators
 *   dispatch(new ComputeTickerIndicatorsJob(
 *       tickerIds: [1, 2, 3],
 *       indicators: ['macd', 'atr', 'adx', 'vwap'],
 *       range: ['from' => '2023-01-01', 'to' => '2023-12-31']
 *   ));
 *
 *   // Minimal dispatch (used by tickers:backfill-indicators)
 *   dispatch(new ComputeTickerIndicatorsJob([1, 2, 3], ['macd','atr']));
 *
 * ============================================================================
 */
class ComputeTickerIndicatorsJob implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels, Batchable;

    /** @var array<int> IDs of tickers to process. */
    public array $tickerIds;

    /** @var array<string> Indicator names to compute (e.g. ['macd','atr']). */
    public array $indicators;

    /** @var array{from?:string,to?:string} Optional date range. */
    public array $range;

    /** @var array Arbitrary parameter overrides. */
    public array $params;

    /** @var bool Whether to also generate feature snapshots after DB writes. */
    public bool $writeSnapshots;

    /** @var int Maximum retry attempts before job is marked as failed. */
    public int $tries = 3;

    /** @var int Maximum job runtime (seconds). */
    public int $timeout = 900; // extended slightly for larger batches

    /**
     * -------------------------------------------------------------------------
     *  Constructor
     * -------------------------------------------------------------------------
     *
     * @param  array<int>  $tickerIds
     * @param  array<string>  $indicators
     * @param  array{from?:string,to?:string}  $range
     * @param  array  $params
     * @param  bool  $writeSnapshots
     */
    public function __construct(
        array $tickerIds,
        array $indicators = [],
        array $range = [],
        array $params = [],
        bool $writeSnapshots = true
    ) {
        $this->tickerIds      = $tickerIds;
        $this->indicators     = $indicators ?: ['macd', 'atr', 'adx', 'vwap'];
        $this->range          = $range;
        $this->params         = $params;
        $this->writeSnapshots = $writeSnapshots;
    }

    /**
     * -------------------------------------------------------------------------
     *  Handle
     * -------------------------------------------------------------------------
     * Executes the indicator computation pipeline for each ticker.
     * Writes results to the database and optionally updates snapshots.
     * -------------------------------------------------------------------------
     */
    public function handle(FeaturePipeline $pipeline): void
    {
        // Safety: skip if batch has been cancelled.
        if (method_exists($this, 'batch') && $this->batch()?->cancelled()) {
            Log::channel('ingest')->warning('â­ï¸ Skipping ComputeTickerIndicatorsJob â€” batch cancelled.', [
                'tickers' => $this->tickerIds,
            ]);
            return;
        }

        Log::channel('ingest')->info('ðŸš€ Starting ComputeTickerIndicatorsJob', [
            'tickers'   => $this->tickerIds,
            'indicators'=> $this->indicators,
            'range'     => $this->range,
            'snapshots' => $this->writeSnapshots ? 'enabled' : 'disabled',
        ]);

        foreach ($this->tickerIds as $tickerId) {
            try {
                $result = $pipeline->runForTicker(
                    tickerId: $tickerId,
                    indicatorNames: $this->indicators,
                    range: $this->range,
                    params: $this->params,
                    writeCoreToDb: true,
                    buildSnapshots: $this->writeSnapshots,
                    primeCache: false
                );

                Log::channel('ingest')->info('âœ… Indicators computed successfully', [
                    'ticker_id'        => $tickerId,
                    'rows_inserted'    => $result['inserted'] ?? null,
                    'snapshots_written'=> $result['snapshots'] ?? null,
                ]);
            } catch (\Throwable $e) {
                Log::channel('ingest')->error('âŒ Indicator computation failed', [
                    'ticker_id' => $tickerId,
                    'message'   => $e->getMessage(),
                    'trace'     => substr($e->getTraceAsString(), 0, 800),
                ]);
                throw $e; // Allow Laravel retry/backoff
            }
        }

        Log::channel('ingest')->info('ðŸ ComputeTickerIndicatorsJob complete', [
            'tickers'    => $this->tickerIds,
            'indicators' => $this->indicators,
        ]);
    }

    /**
     * -------------------------------------------------------------------------
     *  Tags for Horizon / Job Monitoring
     * -------------------------------------------------------------------------
     */
    public function tags(): array
    {
        return [
            'compute',
            'tickers:' . implode(',', array_slice($this->tickerIds, 0, 5)) . (count($this->tickerIds) > 5 ? '...' : ''),
            'indicators:' . implode(',', $this->indicators),
            'snapshots:' . ($this->writeSnapshots ? 'on' : 'off'),
        ];
    }
}app/Jobs/BuildTickerSnapshotJob.php


===== FILE: app/Jobs/BuildTickerSnapshotJob.php =====

<?php

namespace App\Jobs;

use App\Services\Analytics\FeatureSnapshotBuilder;
use Illuminate\Bus\Batchable;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use Illuminate\Support\Facades\Log;

/**
 * Class BuildTickerSnapshotJob
 *
 * Queued job responsible for building (or previewing) JSON feature snapshots
 * for one or more tickers across a specified date range.
 *
 * Each snapshot represents a merged analytics vector containing:
 *   - Computed indicators from ticker_indicators
 *   - Derived analytics (Sharpe Ratio, Beta, Volatility, etc.)
 *   - Optional placeholders for sentiment/embeddings
 *
 * Designed for parallel execution under Laravelâ€™s Bus::batch()
 * via the TickersBuildSnapshots command.
 */
class BuildTickerSnapshotJob implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels, Batchable;

    /** @var array<int> List of ticker IDs to process. */
    public array $tickerIds;

    /** @var array{from?:string,to?:string} Optional date range for computation. */
    public array $range;

    /** @var array Optional runtime parameters (unused for now). */
    public array $params;

    /** @var bool Whether this job runs in dry-run preview mode. */
    public bool $preview;

    /** @var int Maximum retry attempts for transient failures. */
    public int $tries = 3;

    /** @var int Timeout (in seconds) per job execution. */
    public int $timeout = 600;

    /** @var int Backoff delay (seconds) before retrying failed jobs. */
    public int $backoff = 15;

    /**
     * @param array<int> $tickerIds
     * @param array{from?:string,to?:string} $range
     * @param array $params
     * @param bool $preview
     */
    public function __construct(array $tickerIds, array $range = [], array $params = [], bool $preview = false)
    {
        $this->tickerIds = $tickerIds;
        $this->range     = $range;
        $this->params    = $params;
        $this->preview   = $preview;
    }

    /**
     * Execute the job.
     *
     * For each ticker:
     *  - Loads indicator data
     *  - Computes derived metrics
     *  - Builds JSON feature snapshots
     *  - Writes or logs results depending on --preview mode
     */
    public function handle(FeatureSnapshotBuilder $builder): void
    {
        // ---------------------------------------------------------------------
        // 1ï¸âƒ£ Batch cancellation safety check
        // ---------------------------------------------------------------------
        if (method_exists($this, 'batch') && $this->batch()?->cancelled()) {
            Log::channel('ingest')->warning('â­ï¸ Skipping BuildTickerSnapshotJob â€” parent batch cancelled.', [
                'class'   => static::class,
                'tickers' => $this->tickerIds,
            ]);
            return;
        }

        // ---------------------------------------------------------------------
        // 2ï¸âƒ£ Job start log
        // ---------------------------------------------------------------------
        Log::channel('ingest')->info('ðŸš€ Starting BuildTickerSnapshotJob', [
            'tickers' => $this->tickerIds,
            'range'   => $this->range,
            'preview' => $this->preview,
            'job_id'  => $this->job?->getJobId() ?? null,
        ]);

        if ($this->preview) {
            Log::channel('ingest')->info('ðŸ’¡ Preview mode active â€” snapshots will be simulated only (no DB writes).', [
                'tickers' => $this->tickerIds,
            ]);
        }

        // ---------------------------------------------------------------------
        // 3ï¸âƒ£ Sequentially build snapshots for each ticker
        // ---------------------------------------------------------------------
        $totalSnapshots = 0;

        foreach ($this->tickerIds as $index => $tickerId) {
            $pos = $index + 1;
            $total = count($this->tickerIds);

            try {
                Log::channel('ingest')->info("â–¶ï¸ Building snapshot for ticker {$tickerId} ({$pos}/{$total})", [
                    'range'   => $this->range,
                    'preview' => $this->preview,
                ]);

                $res = $builder->buildForTicker($tickerId, $this->range, $this->params, $this->preview);
                $snapCount = $res['snapshots'] ?? 0;
                $totalSnapshots += $snapCount;

                Log::channel('ingest')->info('âœ… Snapshot built successfully', [
                    'ticker_id' => $tickerId,
                    'snapshots' => $snapCount,
                    'range'     => $this->range,
                    'preview'   => $this->preview,
                ]);
            } catch (\Throwable $e) {
                // Handle per-ticker failure safely; let Laravel retry if needed
                Log::channel('ingest')->error('âŒ Snapshot build failed', [
                    'ticker_id' => $tickerId,
                    'error'     => $e->getMessage(),
                    'trace'     => substr($e->getTraceAsString(), 0, 900),
                    'range'     => $this->range,
                    'preview'   => $this->preview,
                ]);

                // Allow retry by rethrowing exception
                throw $e;
            }
        }

        // ---------------------------------------------------------------------
        // 4ï¸âƒ£ Completion log
        // ---------------------------------------------------------------------
        Log::channel('ingest')->info('ðŸ BuildTickerSnapshotJob complete', [
            'tickers'        => $this->tickerIds,
            'snapshots_total'=> $totalSnapshots,
            'preview'        => $this->preview,
        ]);
    }

    /**
     * Tags for Laravel Horizon monitoring.
     */
    public function tags(): array
    {
        return [
            'snapshots',
            'tickers:' . implode(',', $this->tickerIds),
            'preview:' . ($this->preview ? 'true' : 'false'),
            'range:' . ($this->range['from'] ?? 'none') . '-' . ($this->range['to'] ?? 'none'),
        ];
    }
}app/Jobs/IngestTickerFundamentalsJob.php


===== FILE: app/Jobs/IngestTickerFundamentalsJob.php =====

<?php

namespace App\Jobs;

use App\Models\Ticker;
use App\Services\PolygonFundamentalsService;
use Illuminate\Bus\Queueable;
use Illuminate\Bus\Batchable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use Illuminate\Support\Facades\Log;
use Throwable;

/**
 * ============================================================================
 *  IngestTickerFundamentalsJob (Hardened v2.0)
 * ============================================================================
 *
 *  âœ” Serialization-safe â€” no closures, no console objects, no Symfony input
 *  âœ” Automatically sanitizes options down to primitive scalars/arrays
 *  âœ” Strong logging + structured context for debugging
 *  âœ” Safe for Bus::batch() + redis/database queues (Laravel 10â€“12)
 *  âœ” Prevents the "Cannot assign ... suggestedValues" error permanently
 *
 *  Payload Rules:
 *  --------------
 *  Jobs may only contain:
 *      - ints
 *      - strings
 *      - floats
 *      - bools
 *      - null
 *      - arrays of primitives
 *
 *  Anything else (objects, closures, Symfony console defs) is stripped.
 *
 * ============================================================================
 */
class IngestTickerFundamentalsJob implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels, Batchable;

    /** @var int */
    public int $tickerId;

    /** @var array  Safe, sanitized option list */
    public array $options;

    /** Retry behavior */
    public int $tries   = 3;
    public int $backoff = 30; // seconds

    /**
     * @param int   $tickerId
     * @param array $options   Raw options (may contain closures/objects before sanitization)
     */
    public function __construct(int $tickerId, array $options = [])
    {
        $this->tickerId = $tickerId;

        // ðŸ§¹ SANITIZE: ensure only primitives/arrays survive
        $this->options = $this->sanitizeOptions($options);
    }

    /**
     * Sanitize options to guarantee queue-safe serialization.
     */
    private function sanitizeOptions(array $options): array
    {
        $clean = [];

        foreach ($options as $key => $value) {
            // Allow scalar
            if (is_scalar($value) || $value === null) {
                $clean[$key] = $value;
                continue;
            }

            // Allow arrays but recursively sanitize
            if (is_array($value)) {
                $clean[$key] = $this->sanitizeOptions($value);
                continue;
            }

            // Drop anything else (closure, object, etc.)
            $clean[$key] = null;

            Log::channel('ingest')->warning("âš ï¸ Dropped non-serializable option value in IngestTickerFundamentalsJob", [
                'key'         => $key,
                'value_type'  => gettype($value),
                'value_class' => is_object($value) ? get_class($value) : null,
            ]);
        }

        return $clean;
    }

    /**
     * Main job executor.
     */
    public function handle(PolygonFundamentalsService $service): void
    {
        $ticker = Ticker::find($this->tickerId);

        if (! $ticker) {
            Log::channel('ingest')->warning("âš ï¸ Ticker not found for fundamentals ingestion", [
                'ticker_id' => $this->tickerId,
                'options'   => $this->options,
            ]);
            return;
        }

        $symbol = $ticker->ticker;

        Log::channel('ingest')->info("â–¶ï¸ Fundamentals job starting", [
            'symbol'       => $symbol,
            'ticker_id'    => $this->tickerId,
            'batch_id'     => $this->batchId ?? 'none',
            'options'      => $this->options,
        ]);

        try {
            // --- Begin API call ---
            Log::channel('ingest')->info("ðŸŒ Calling PolygonFundamentalsService::fetchAndStoreFundamentals()", [
                'symbol' => $symbol,
            ]);

            $count = $service->fetchAndStoreFundamentals($symbol, $this->options);

            // --- Validate service return ---
            if (!is_numeric($count)) {
                Log::channel('ingest')->warning("âš ï¸ Fundamentals service returned non-numeric result", [
                    'symbol' => $symbol,
                    'type'   => gettype($count),
                    'value'  => $count,
                ]);
            } else {
                Log::channel('ingest')->info("âœ… Fundamentals ingestion completed", [
                    'symbol'  => $symbol,
                    'records' => (int) $count,
                ]);
            }

            Log::channel('ingest')->info("ðŸ Fundamentals job complete", [
                'symbol'     => $symbol,
                'ticker_id'  => $this->tickerId,
                'batch_id'   => $this->batchId ?? 'none',
            ]);

        } catch (Throwable $e) {
            Log::channel('ingest')->error("âŒ Fundamentals job failed", [
                'symbol'     => $symbol,
                'ticker_id'  => $this->tickerId,
                'message'    => $e->getMessage(),
                'batch_id'   => $this->batchId ?? 'none',
                'trace'      => substr($e->getTraceAsString(), 0, 1200),
            ]);

            // Allow Laravel queue worker to retry automatically
            throw $e;
        }
    }

    /**
     * Tags for horizon/queue debugging.
     */
    public function tags(): array
    {
        return [
            'fundamentals',
            'ticker:' . $this->tickerId,
        ];
    }
}
[EOF: app/Jobs]
