===== GPT DUMP GENERATED: 2025-11-03T10:24:19Z =====
===== DIRECTORY: app/Services =====

app/Services/TickerSlugService.php


===== FILE: app/Services/TickerSlugService.php =====

<?php

namespace App\Services;

use Illuminate\Support\Str;

class TickerSlugService
{
    /**
     * Generate a URL-safe slug from ticker + name.
     * Example: ticker=AAPL, name="Apple Inc." => "apple-inc"
     * We intentionally *do not* include ticker in the slug itself because the URL will include ticker before the slug.
     *
     * @param string|null $name
     * @return string|null
     */
    public function slugFromName(?string $name): ?string
    {
        if (empty($name)) {
            return null;
        }

        // Generate a slug from the company name, limit length to 80 chars
        $slug = Str::slug($name);
        return Str::limit($slug, 80, '');
    }
}
app/Services/LLMContracts/LLMProviderInterface.php


===== FILE: app/Services/LLMContracts/LLMProviderInterface.php =====

<?php

namespace App\Services\LLMContracts;

interface LLMProviderInterface
{
    public function analyze(string $ticker, string $promptTemplate, array $context = []): array;

    public function extractStructuredFromText(string $text): ?array;
}
app/Services/PolygonApiClient.php


===== FILE: app/Services/PolygonApiClient.php =====

<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;
use Illuminate\Support\Facades\Log;

class PolygonApiClient
{
    protected string $baseUrl;
    protected string $apiKey;
    protected int $timeout;
    protected int $maxRetries;

    public function __construct()
    {
        $this->baseUrl = rtrim(config('services.polygon.base') ?? env('POLYGON_API_BASE', 'https://api.polygon.io'), '/');
        $this->apiKey = config('services.polygon.key') ?? env('POLYGON_API_KEY');
        $this->timeout = (int) (env('POLYGON_API_TIMEOUT', 30));
        $this->maxRetries = (int) (env('POLYGON_API_RETRIES', 3));
    }

    /**
     * Perform a GET request with built-in retries, rate-limit handling, and backoff.
     */
    public function get(string $endpointOrUrl, array $params = [])
    {
        $url = str_starts_with($endpointOrUrl, 'http')
            ? $endpointOrUrl
            : "{$this->baseUrl}/" . ltrim($endpointOrUrl, '/');

        // Ensure API key is always attached
        $params['apiKey'] = $params['apiKey'] ?? $this->apiKey;
        $url .= (str_contains($url, '?') ? '&' : '?') . http_build_query($params);

        $attempt = 0;
        $waitSeconds = 2;

        while (true) {
            $attempt++;
            try {
                $response = Http::timeout($this->timeout)->get($url);
            } catch (\Throwable $e) {
                Log::error("Polygon HTTP exception: {$e->getMessage()}", ['url' => $url]);
                if ($attempt >= $this->maxRetries) {
                    return response()->json(['error' => $e->getMessage()], 500);
                }
                sleep($waitSeconds);
                $waitSeconds *= 2;
                continue;
            }

            // Handle rate limit
            if ($response->status() === 429) {
                $retryAfter = (int) ($response->header('Retry-After') ?? $waitSeconds);
                Log::warning("Polygon API 429 - sleeping {$retryAfter}s");
                sleep($retryAfter);
                continue;
            }

            // Retry on 5xx
            if ($response->serverError() && $attempt < $this->maxRetries) {
                Log::warning("Polygon server error {$response->status()} ‚Äî retrying in {$waitSeconds}s");
                sleep($waitSeconds);
                $waitSeconds *= 2;
                continue;
            }

            return $response;
        }
    }
}app/Services/LLMProviders/GeminiProvider.php


===== FILE: app/Services/LLMProviders/GeminiProvider.php =====

<?php

namespace App\Services\LLMProviders;

use Illuminate\Support\Facades\Http;
use App\Services\LLMContracts\LLMProviderInterface;

class GeminiProvider implements LLMProviderInterface
{
    public function analyze(string $ticker, string $promptTemplate, array $context = []): array
    {
        $prompt = $this->renderPrompt($promptTemplate, ['ticker'=>strtoupper($ticker)] + $context);

        $response = Http::withToken(config('services.gemini.key'))
            ->post('https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent', [
                'contents' => [['parts' => [['text' => $prompt]]]],
            ]);

        return $response->json();
    }

    protected function renderPrompt(string $template, array $data): string {
        foreach ($data as $k=>$v) $template = str_replace('{{'.$k.'}}',$v,$template);
        return $template;
    }

    public function extractStructuredFromText(string $text): ?array {
        $json = $this->findJson($text);
        return $json ? json_decode($json,true) : null;
    }

    protected function findJson(string $text): ?string {
        $start=strrpos($text,'{'); $end=strrpos($text,'}');
        return ($start!==false && $end!==false) ? substr($text,$start,$end-$start+1) : null;
    }
}app/Services/LLMProviders/GrokProvider.php


===== FILE: app/Services/LLMProviders/GrokProvider.php =====

<?php

namespace App\Services\LLMProviders;

use Illuminate\Support\Facades\Http;
use App\Services\LLMContracts\LLMProviderInterface;

class GrokProvider implements LLMProviderInterface
{
    public function analyze(string $ticker, string $promptTemplate, array $context = []): array
    {
        $prompt = $this->renderPrompt($promptTemplate, ['ticker'=>strtoupper($ticker)] + $context);

        $response = Http::withToken(config('services.grok.key'))
            ->post(config('services.grok.endpoint', 'https://api.x.ai/v1/chat/completions'), [
                'model' => config('services.grok.model', 'grok-beta'),
                'messages' => [
                    ['role'=>'system','content'=>'You are a helpful financial analyst.'],
                    ['role'=>'user','content'=>$prompt],
                ],
            ]);

        return $response->json();
    }

    protected function renderPrompt(string $template, array $data): string {
        foreach ($data as $k=>$v) $template = str_replace('{{'.$k.'}}',$v,$template);
        return $template;
    }

    public function extractStructuredFromText(string $text): ?array {
        $json = $this->findJson($text);
        return $json ? json_decode($json,true) : null;
    }

    protected function findJson(string $text): ?string {
        $start=strrpos($text,'{'); $end=strrpos($text,'}');
        return ($start!==false && $end!==false) ? substr($text,$start,$end-$start+1) : null;
    }
}app/Services/LLMProviders/OpenAiProvider.php


===== FILE: app/Services/LLMProviders/OpenAiProvider.php =====

<?php

namespace App\Services\LLMProviders;

use Illuminate\Support\Facades\Http;
use Illuminate\Support\Facades\Log;
use App\Services\LLMContracts\LLMProviderInterface;
use RuntimeException;
use Throwable;

class OpenAiProvider implements LLMProviderInterface
{
    /**
     * Perform analysis using the OpenAI Responses API (v1/responses)
     * with provider-level hardening (retries, backoff, validation).
     */
    public function analyze(string $ticker, string $promptTemplate, array $context = []): array
    {
        $prompt = $this->renderPrompt(
            $promptTemplate,
            array_merge($context, ['ticker' => strtoupper($ticker)])
        );

        $apiKey   = config('services.openai.key');
        $endpoint = config('services.openai.endpoint', 'https://api.openai.com/v1/responses');
        $model    = config('services.openai.model', 'gpt-4.1-mini');

        if (empty($apiKey)) {
            throw new RuntimeException('Missing OpenAI API key.');
        }

        $payload = [
            'model' => $model,
            'input' => [
                [
                    'role' => 'system',
                    'content' => 'You are a helpful financial analyst that provides concise, structured insights.'
                ],
                [
                    'role' => 'user',
                    'content' => $prompt
                ]
            ],
            'temperature' => 0.2,
            'max_output_tokens' => 1200,
        ];

        $maxAttempts = 3;
        $delaySeconds = 5;

        for ($attempt = 1; $attempt <= $maxAttempts; $attempt++) {
            try {
                $response = Http::withToken($apiKey)
                    ->timeout(60)
                    ->acceptJson()
                    ->post($endpoint, $payload);

                $json = $response->json();

                Log::debug('OpenAI raw response', [
                    'provider' => 'openai',
                    'ticker'   => $ticker,
                    'attempt'  => $attempt,
                    'raw'      => $json,
                ]);

                // Handle non-2xx responses
                if ($response->failed()) {
                    $status = $response->status();
                    $message = $json['error']['message'] ?? 'Unknown API error';

                    // Retry automatically on transient or rate-limit errors
                    if (in_array($status, [408, 429, 500, 502, 503, 504], true)) {
                        Log::warning("Transient OpenAI error [{$status}]: {$message}. Retrying in {$delaySeconds}s‚Ä¶");
                        sleep($delaySeconds);
                        $delaySeconds *= 2; // Exponential backoff
                        continue;
                    }

                    throw new RuntimeException("OpenAI API error [{$status}]: {$message}");
                }

                // Validate structure before parsing
                if (!isset($json['output'][0]['content'][0]['text'])) {
                    throw new RuntimeException('Malformed API response: missing content.');
                }

                $content = trim($json['output'][0]['content'][0]['text'] ?? '');

                if ($content === '') {
                    throw new RuntimeException('Provider returned empty content.');
                }

                return [
                    'content' => $content,
                    'raw'     => $json,
                ];
            } catch (Throwable $e) {
                Log::error("OpenAI attempt {$attempt} failed: {$e->getMessage()}");

                if ($attempt < $maxAttempts) {
                    sleep($delaySeconds);
                    $delaySeconds *= 2;
                    continue;
                }

                throw new RuntimeException("OpenAI analysis failed after {$attempt} attempts: " . $e->getMessage(), 0, $e);
            }
        }

        // Should not reach here
        throw new RuntimeException('OpenAI analysis aborted after maximum retries.');
    }

    /**
     * Simple template interpolation.
     */
    protected function renderPrompt(string $template, array $data): string
    {
        foreach ($data as $k => $v) {
            $template = str_replace('{{' . $k . '}}', $v, $template);
        }
        return $template;
    }

    /**
     * Extracts structured JSON from a text blob.
     */
    public function extractStructuredFromText(string $text): ?array
    {
        $json = $this->findJson($text);
        return $json ? json_decode($json, true) : null;
    }

    /**
     * Finds JSON within a text body.
     */
    protected function findJson(string $text): ?string
    {
        $start = strpos($text, '{');
        $end = strrpos($text, '}');

        if ($start === false || $end === false || $end <= $start) {
            return null;
        }

        $possibleJson = substr($text, $start, $end - $start + 1);

        // Basic sanity check before decoding
        return str_contains($possibleJson, ':') ? $possibleJson : null;
    }
}app/Services/PolygonPriceHistoryService.php


===== FILE: app/Services/PolygonPriceHistoryService.php =====

<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Carbon;
use Throwable;

/**
 * Service: PolygonPriceHistoryService
 * -----------------------------------
 * Responsible for retrieving and persisting historical OHLCV bar data
 * from the Polygon.io Aggregates API (/v2/aggs/ticker/...).
 *
 * This service is used by higher-level ingestion services to:
 *  - Fetch remote daily bars (open/high/low/close/volume)
 *  - Handle retry logic, throttling, and server exceptions
 *  - Upsert resulting bars into ticker_price_histories efficiently
 *
 * Logging verbosity is intentionally high to enable granular debugging
 * of ingestion, response counts, and API behavior differences across
 * instrument types (CS, PFD, UNIT, ETF, etc.).
 *
 * üöÄ v2.6.5 ‚Äî Added pre-upsert sanitization to skip abnormal numeric values
 *             that exceed safe column ranges (prevents 22003 SQLSTATE errors).
 */
class PolygonPriceHistoryService
{
    protected string $baseUrl;
    protected string $apiKey;
    protected int $timeout;
    protected int $maxRetries;
    protected string $logChannel;

    /**
     * Constructor: Initializes configuration and HTTP defaults.
     */
    public function __construct()
    {
        $this->baseUrl = rtrim(config('services.polygon.base') ?? env('POLYGON_API_BASE', 'https://api.polygon.io'), '/');
        $this->apiKey = config('services.polygon.key') ?? env('POLYGON_API_KEY');
        $this->timeout = (int)(env('POLYGON_API_TIMEOUT', 30));
        $this->maxRetries = (int)(env('POLYGON_API_RETRIES', 3));
        $this->logChannel = 'ingest';
    }

    /**
     * Fetch aggregated OHLCV data for a ticker between two dates.
     *
     * @param  string  $symbol      The ticker symbol (case-sensitive)
     * @param  int     $multiplier  The aggregation multiplier (usually 1)
     * @param  string  $timespan    The unit of time (e.g. 'day')
     * @param  string  $from        ISO date string (YYYY-MM-DD)
     * @param  string  $to          ISO date string (YYYY-MM-DD)
     * @param  array   $extraParams Optional extra query params
     * @return array   The list of returned bars (may be empty)
     */
    public function fetchAggregates(string $symbol, int $multiplier, string $timespan, string $from, string $to, array $extraParams = []): array
    {
        $endpoint = "/v2/aggs/ticker/{$symbol}/range/{$multiplier}/{$timespan}/{$from}/{$to}";
        $params = array_merge(['apiKey' => $this->apiKey, 'limit' => 50000], $extraParams);
        $url = $this->baseUrl . $endpoint . '?' . http_build_query($params);

        $attempt = 0;
        $wait = 1;
        $log = Log::channel($this->logChannel);
        $startedAt = now()->toDateTimeString();

        $log->info("üß≠ [{$startedAt}] FetchAggregates called", [
            'symbol' => $symbol,
            'endpoint' => $endpoint,
            'from' => $from,
            'to' => $to,
            'url' => $url,
        ]);

        while (true) {
            $attempt++;
            $log->debug("üì° Attempt {$attempt} to fetch {$symbol} (wait={$wait}s)");

            try {
                // Send HTTP request
                $resp = Http::timeout($this->timeout)->get($url);
                $status = $resp->status();
                $body = $resp->body();

                // ‚úÖ Successful HTTP 200
                if ($resp->successful()) {
                    $json = $resp->json();

                    if (!is_array($json)) {
                        $log->error("‚ùå Invalid JSON response for {$symbol}", [
                            'status' => $status,
                            'body_snippet' => substr($body, 0, 300),
                        ]);
                        return [];
                    }

                    $count = $json['resultsCount'] ?? count($json['results'] ?? []);
                    $log->info("‚úÖ Polygon response for {$symbol}: status={$status}, count={$count}", [
                        'queryCount' => $json['queryCount'] ?? null,
                        'statusField' => $json['status'] ?? null,
                    ]);

                    if ($count === 0) {
                        $log->warning("‚ö†Ô∏è No results returned for {$symbol}", [
                            'queryCount' => $json['queryCount'] ?? null,
                            'resultsCount' => $json['resultsCount'] ?? null,
                            'statusField' => $json['status'] ?? null,
                        ]);
                    }

                    return $json['results'] ?? [];
                }

                // üö¶ Rate-limited: 429 Too Many Requests
                if ($status === 429) {
                    $retryAfter = $resp->header('Retry-After') ?? $wait;
                    $log->warning("‚è≥ 429 Too Many Requests for {$symbol}, retrying in {$retryAfter}s (attempt {$attempt})");
                    sleep((int)$retryAfter);
                }
                // üí• 5xx Server Error
                elseif ($resp->serverError()) {
                    $log->warning("‚ö†Ô∏è Server error for {$symbol}: status={$status}");
                    if ($attempt >= $this->maxRetries) {
                        $log->error("‚ùå Aborting {$symbol} after {$attempt} server errors");
                        break;
                    }
                    sleep($wait);
                    $wait *= 2;
                }
                // ‚ö†Ô∏è 4xx Client Error (e.g. 400/404)
                else {
                    $log->warning("‚ö†Ô∏è Client error for {$symbol}: status={$status}", [
                        'body_snippet' => substr($body, 0, 300),
                    ]);
                    return [];
                }

            } catch (Throwable $e) {
                $log->error("üí• HTTP exception on attempt {$attempt} for {$symbol}: {$e->getMessage()}");
                if ($attempt >= $this->maxRetries) {
                    $log->error("üö´ Giving up on {$symbol} after {$attempt} attempts");
                    break;
                }
                sleep($wait);
                $wait *= 2;
            }

            // Stop looping after repeated failures
            if ($attempt >= ($this->maxRetries + 3)) {
                $log->error("üõë Max retry limit reached for {$symbol}");
                break;
            }
        }

        $log->warning("üö´ Returning empty result for {$symbol} after {$attempt} attempts");
        return [];
    }

    /**
     * Upsert Polygon bar data into ticker_price_histories.
     *
     * v2.7.0 ‚Äî Hardened Sanitization Layer
     * ------------------------------------
     * This version adds stronger guards against malformed or extreme values
     * that could trigger SQLSTATE[22003] or silently corrupt analytics data.
     *
     * Key protections:
     *  ‚Ä¢ Skips bars with any NaN, INF, negative, or absurdly large values.
     *  ‚Ä¢ Ensures all numeric fields are finite, positive, and within sane bounds.
     *  ‚Ä¢ Logs granular warnings per skipped bar.
     *
     * @param  int    $tickerId
     * @param  string $symbol
     * @param  string $resolution
     * @param  array  $bars
     * @return int
     */
    public function upsertBars(int $tickerId, string $symbol, string $resolution, array $bars): int
    {
        $logger = Log::channel($this->logChannel);

        if (empty($bars)) {
            $logger->warning("‚ö†Ô∏è No bars provided to upsert for {$symbol}");
            return 0;
        }

        $now = Carbon::now()->toDateTimeString();
        $rows = [];
        $mappedCount = 0;

        foreach ($bars as $b) {
            try {
                if (empty($b['t'])) {
                    $logger->debug("‚è≥ Skipping bar with missing timestamp for {$symbol}");
                    continue;
                }

                // üß© SANITIZATION: Hardened numeric checks
                // ------------------------------------------------------
                $fields = ['o', 'h', 'l', 'c', 'vw'];
                $valid = true;
                foreach ($fields as $field) {
                    if (!array_key_exists($field, $b)) {
                        continue;
                    }

                    $val = (float)$b[$field];

                    // Reject NaN, INF, absurdly large, or non-sensical values
                    if (
                        !is_finite($val) ||
                        $val <= 0 ||                        // zero or negative price
                        $val > 10_000_000 ||                // 10 million upper limit
                        $val < 0.0001                       // lower bound sanity floor
                    ) {
                        $logger->warning("‚ö†Ô∏è Skipping abnormal {$field}={$b[$field]} for {$symbol} at {$b['t']}");
                        $valid = false;
                        break;
                    }
                }

                if (!$valid) {
                    continue; // Skip entire bar
                }

                // Convert Polygon‚Äôs millisecond timestamp (UTC) ‚Üí MySQL datetime
                $ts = Carbon::createFromTimestampMsUTC((int)$b['t'])->format('Y-m-d H:i:s');

                $rows[] = [
                    'ticker_id'   => $tickerId,
                    'resolution'  => $resolution,
                    't'           => $ts,
                    'year'        => (int)substr($ts, 0, 4),
                    'o'           => $b['o'] ?? null,
                    'h'           => $b['h'] ?? null,
                    'l'           => $b['l'] ?? null,
                    'c'           => $b['c'] ?? null,
                    'v'           => isset($b['v']) ? (int)$b['v'] : null,
                    'vw'          => $b['vw'] ?? null,
                    'raw'         => json_encode($b),
                    'created_at'  => $now,
                    'updated_at'  => $now,
                ];

                $mappedCount++;
            } catch (Throwable $e) {
                $logger->warning("‚ö†Ô∏è Skipped malformed bar for {$symbol}: {$e->getMessage()}");
            }
        }

        if ($mappedCount === 0) {
            $logger->warning("‚ö†Ô∏è All bars failed to map for {$symbol}");
            return 0;
        }

        try {
            $before = DB::table('ticker_price_histories')->where('ticker_id', $tickerId)->count();

            DB::table('ticker_price_histories')->upsert(
                $rows,
                ['ticker_id', 'resolution', 't'],
                ['o', 'h', 'l', 'c', 'v', 'vw', 'raw', 'updated_at']
            );

            $after = DB::table('ticker_price_histories')->where('ticker_id', $tickerId)->count();
            $inserted = max($after - $before, 0);

            $logger->info("üíæ Upserted {$mappedCount} mapped bars for {$symbol} (net change: +{$inserted})");
            return $mappedCount;
        } catch (Throwable $e) {
            $logger->error("‚ùå Upsert failed for {$symbol}: {$e->getMessage()}");
            return 0;
        }
    }
}app/Services/LLMProviderFactory.php


===== FILE: app/Services/LLMProviderFactory.php =====

<?php

namespace App\Services;

use App\Services\LLMProviders\{OpenAiProvider, GeminiProvider, GrokProvider};
use App\Services\LLMContracts\LLMProviderInterface;
use InvalidArgumentException;

class LLMProviderFactory
{
    public static function make(string $provider): LLMProviderInterface
    {
        return match(strtolower($provider)) {
            'openai' => new OpenAiProvider(),
            'gemini' => new GeminiProvider(),
            'grok'   => new GrokProvider(),
            default  => throw new InvalidArgumentException("Unsupported provider [$provider]"),
        };
    }
}app/Services/PolygonTickerPriceHistoryService.php


===== FILE: app/Services/PolygonTickerPriceHistoryService.php =====

<?php

namespace App\Services;

use Illuminate\Support\Facades\Log;
use Throwable;

/**
 * Service: PolygonTickerPriceHistoryService
 * -----------------------------------------
 * Coordinates fetching and storing of historical price data
 * for a given ticker symbol by delegating API retrieval to
 * PolygonPriceHistoryService and managing ingestion behavior
 * (logging, retries, normalization, and data persistence).
 *
 * This service adds robustness for ticker symbol casing issues
 * that arise with non-CS (Common Stock) instruments such as:
 *   - Preferred shares (e.g., ABRpD, AHTpF)
 *   - Units (e.g., XYZ.U)
 *   - ETFs and structured products
 *
 * Polygon‚Äôs /v2/aggs endpoint is case-sensitive for such symbols,
 * so this service preserves their mixed case to ensure valid responses.
 */
class PolygonTickerPriceHistoryService
{
    /**
     * The underlying low-level Polygon API interface.
     */
    protected PolygonPriceHistoryService $polygon;

    /**
     * The logging channel used for ingestion tracking.
     */
    protected string $logChannel;

    /**
     * Construct the service.
     */
    public function __construct(PolygonPriceHistoryService $polygon)
    {
        $this->polygon = $polygon;
        $this->logChannel = 'ingest';
    }

    /**
     * Fetch and store historical price bars for a given ticker.
     *
     * This method:
     *  - Normalizes ticker casing based on asset type
     *  - Requests historical aggregates from Polygon
     *  - Retries automatically with alternate casing if no results
     *  - Delegates persistence to PolygonPriceHistoryService::upsertBars()
     *  - Logs all key steps and results for visibility
     *
     * @param  object  $ticker      The Ticker model instance or object
     * @param  string  $rangeFrom   ISO date string for start of range (e.g. '2020-01-01')
     * @param  string  $rangeTo     ISO date string for end of range (e.g. '2025-11-03')
     */
    public function fetchAndStore(object $ticker, string $rangeFrom, string $rangeTo): void
    {
        $logger = Log::channel($this->logChannel);

        // Resolve symbol and sanity-check required attributes
        $symbol = $ticker->ticker ?? $ticker->symbol ?? null;

        if (empty($symbol) || empty($ticker->id)) {
            $logger->error('‚ùå Ticker object missing symbol or ID', ['ticker' => $ticker]);
            return;
        }

        // Normalize symbol according to asset type
        $normalizedSymbol = $this->normalizeSymbol($ticker);
        $tickerId = (int)$ticker->id;
        $resolution = '1d';
        $multiplier = 1;
        $timespan = 'day';

        $logger->info("üìà Fetching Polygon data for {$normalizedSymbol} ({$rangeFrom} ‚Üí {$rangeTo})");

        try {
            // Attempt initial fetch
            $bars = $this->polygon->fetchAggregates($normalizedSymbol, $multiplier, $timespan, $rangeFrom, $rangeTo);

            // If Polygon returns nothing, retry with raw/original symbol casing
            if (empty($bars)) {
                $altSymbol = $symbol;
                if ($altSymbol !== $normalizedSymbol) {
                    $logger->warning("üîÅ No results for {$normalizedSymbol}, retrying with alt case: {$altSymbol}");
                    $bars = $this->polygon->fetchAggregates($altSymbol, $multiplier, $timespan, $rangeFrom, $rangeTo);
                }
            }

            // Still no data? Likely illiquid or unsupported instrument
            if (empty($bars)) {
                $logger->warning("‚ö†Ô∏è No data returned for {$normalizedSymbol} ({$rangeFrom} ‚Üí {$rangeTo}). Possibly illiquid or unsupported.");
                return;
            }

            // Persist to database
            $count = $this->polygon->upsertBars($tickerId, $normalizedSymbol, $resolution, $bars);

            $logger->info("‚úÖ Stored {$count} bars for {$normalizedSymbol} ({$rangeFrom} ‚Üí {$rangeTo})");
        } catch (Throwable $e) {
            // Catch and log unexpected runtime exceptions
            $logger->error("‚ùå Exception fetching/storing data for {$normalizedSymbol}: {$e->getMessage()}", [
                'ticker_id' => $ticker->id,
                'symbol'    => $normalizedSymbol,
                'trace'     => $e->getTraceAsString(),
            ]);
        }
    }

    /**
     * Normalize ticker casing for Polygon endpoints.
     *
     * Polygon‚Äôs API is case-sensitive for non-common-stock tickers.
     * This helper:
     *   - Uppercases symbols for common stock (type 'CS')
     *   - Preserves mixed case for preferreds, units, ETFs, etc.
     *
     * Example:
     *   CS   ‚Üí 'AAPL'
     *   PFD  ‚Üí 'ABRpD'
     *   UNIT ‚Üí 'XYZ.U'
     *
     * @param  object  $ticker
     * @return string  Normalized symbol string ready for Polygon API
     */
    protected function normalizeSymbol(object $ticker): string
    {
        $raw = trim($ticker->ticker ?? $ticker->symbol ?? '');

        // Detect asset type if available
        $type = strtoupper($ticker->type ?? $ticker->asset_type ?? '');

        // Only force-uppercase for standard common stock
        if ($type === 'CS') {
            return strtoupper($raw);
        }

        // Preserve case otherwise
        return $raw;
    }
}app/Services/Compute/FeatureSnapshotBuilder.php


===== FILE: app/Services/Compute/FeatureSnapshotBuilder.php =====

<?php

namespace App\Services\Analytics;

use App\Services\Compute\FeaturePipeline;
use Illuminate\Support\Facades\Log;

/**
 * Class FeatureSnapshotBuilder
 *
 * Generates JSON-encoded ‚Äúfeature vectors‚Äù for a given ticker using the
 * configured snapshot-layer indicators. Each vector represents a daily
 * aggregation of multiple indicator values (per config/indicators.php).
 *
 * Responsibilities:
 * - Delegates actual math to FeaturePipeline.
 * - Persists results to ticker_feature_snapshots.
 * - Called by BuildTickerSnapshotJob or artisan command.
 *
 * Example usage:
 *   $builder = app(FeatureSnapshotBuilder::class);
 *   $builder->buildForTicker($id, ['from'=>'2020-01-01']);
 */
class FeatureSnapshotBuilder
{
    public function __construct(private FeaturePipeline $pipeline)
    {
    }

    /**
     * Execute snapshot computation for a single ticker.
     *
     * @param int  $tickerId   The ticker‚Äôs numeric ID.
     * @param array{from?:string,to?:string} $range  Optional date filters.
     * @param array $params  Optional indicator-specific overrides.
     * @return array{snapshots:int} Number of snapshot records inserted/updated.
     */
    public function buildForTicker(int $tickerId, array $range = [], array $params = []): array
    {
        $snapshotSet = config('indicators.storage.ticker_feature_snapshots', []);

        if (empty($snapshotSet)) {
            Log::channel('ingest')->warning('‚ö†Ô∏è No snapshot indicators configured in config/indicators.php.');
            return ['snapshots' => 0];
        }

        $result = $this->pipeline->runForTicker(
            tickerId: $tickerId,
            indicatorNames: $snapshotSet,
            range: $range,
            params: $params,
            writeCoreToDb: false,
            buildSnapshots: true,
            primeCache: false
        );

        Log::channel('ingest')->info('üß± Feature snapshot built', [
            'ticker_id' => $tickerId,
            'snapshot_count' => $result['snapshots'],
        ]);

        return ['snapshots' => $result['snapshots']];
    }
}app/Services/Compute/FeatureSnapshotService.php


===== FILE: app/Services/Compute/FeatureSnapshotService.php =====

<?php

namespace App\Services\Compute;

use App\Models\TickerFeatureSnapshot;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;

/**
 * Class FeatureSnapshotService
 *
 * Responsible for consolidating per-indicator rows into compact per-day feature vectors.
 *
 * Role in pipeline:
 * - After indicators are computed for a ticker (via FeaturePipeline),
 *   this service aggregates all indicator results for each timestamp
 *   and writes a JSON blob into `ticker_feature_snapshots`.
 *
 * Benefits:
 * - Reduces 20+ indicator rows into one daily record.
 * - Provides AI/ML-ready structure for model ingestion.
 * - Decouples heavy computation from data consumption layers.
 */
class FeatureSnapshotService
{
    /**
     * Build or update feature snapshots for a single ticker.
     *
     * @param int   $tickerId
     * @param array $rows Array of computed indicators (from FeaturePipeline)
     *
     * Expected input format:
     * [
     *   ['t' => '2025-10-30', 'indicator' => 'sma_20', 'value' => 142.5, 'meta' => null],
     *   ['t' => '2025-10-30', 'indicator' => 'ema_12', 'value' => 143.0, 'meta' => null],
     *   ...
     * ]
     *
     * This will consolidate by timestamp:
     * {
     *   "sma_20": 142.5,
     *   "ema_12": 143.0,
     *   ...
     * }
     */
    public function upsertSnapshots(int $tickerId, array $rows): void
    {
        if (empty($rows)) {
            Log::channel('ingest')->info("üü° No rows passed to FeatureSnapshotService", ['ticker_id' => $tickerId]);
            return;
        }

        // Group indicators by timestamp
        $grouped = [];
        foreach ($rows as $r) {
            $t = substr($r['t'], 0, 10); // daily resolution
            $grouped[$t][$r['indicator']] = $r['value'];
        }

        $now = now()->toDateTimeString();
        $payload = [];

        foreach ($grouped as $date => $indicators) {
            $payload[] = [
                'ticker_id'  => $tickerId,
                't'          => $date,
                'indicators' => json_encode($indicators),
                'created_at' => $now,
                'updated_at' => $now,
            ];
        }

        DB::table('ticker_feature_snapshots')->upsert(
            $payload,
            ['ticker_id', 't'],
            ['indicators', 'updated_at']
        );

        Log::channel('ingest')->info("üì¶ Feature snapshots upserted", [
            'ticker_id' => $tickerId,
            'snapshots' => count($payload),
        ]);
    }
}app/Services/Compute/Indicators/VolatilityIndicator.php


===== FILE: app/Services/Compute/Indicators/VolatilityIndicator.php =====

<?php

namespace App\Services\Compute\Indicators;

use App\Services\Compute\BaseIndicator;

/**
 * VolatilityIndicator
 *
 * Computes rolling price volatility using standard deviation of returns.
 *
 * Math summary:
 *   Volatility = StdDev(returns over N) * sqrt(252)
 *
 * Characteristics:
 * - Represents annualized historical volatility (percentage).
 * - Core metric for portfolio risk and derivative pricing.
 *
 * Params:
 *   - period (int): rolling window (default: 20)
 */
class VolatilityIndicator extends BaseIndicator
{
    public string $name = 'volatility';
    public string $displayName = 'Historical Volatility';
    public bool $multiSeries = false;

    public array $defaults = [
        'period' => 20,
    ];

    public function compute(array $bars, array $params = []): array
    {
        $bars = $this->normalizeBars($bars);
        $opts = $this->opts($params);
        $period = (int)$opts['period'];

        $closes = array_column($bars, 'c');
        $returns = $this->returns($closes);
        $rows = [];

        // Rolling volatility (annualized)
        for ($i = $period; $i < count($returns); $i++) {
            $slice = array_slice($returns, $i - $period, $period);
            $std = $this->stddev($slice);
            $vol = $std * sqrt(252); // annualize
            $rows[] = [
                't' => $bars[$i]['t'],
                'indicator' => "volatility_{$period}",
                'value' => round($vol * 100, 6), // convert to %
                'meta' => json_encode(['std' => $std]),
            ];
        }

        return $rows;
    }
}app/Services/Compute/Indicators/ADXIndicator.php


===== FILE: app/Services/Compute/Indicators/ADXIndicator.php =====

<?php

namespace App\Services\Compute\Indicators;

use App\Services\Compute\BaseIndicator;

/**
 * ADXIndicator
 *
 * Computes the Average Directional Index ‚Äî a trend strength indicator
 * derived from directional movement (+DI, -DI).
 *
 * Math summary:
 *   +DM = High_t - High_(t-1) if greater than (Low_(t-1) - Low_t)
 *   -DM = Low_(t-1) - Low_t   if greater than (High_t - High_(t-1))
 *   TR  = max(High - Low, abs(High - Close_(t-1)), abs(Low - Close_(t-1)))
 *
 *   +DI = 100 * (Smoothed +DM / Smoothed TR)
 *   -DI = 100 * (Smoothed -DM / Smoothed TR)
 *   DX  = 100 * |(+DI - -DI)| / (+DI + -DI)
 *   ADX = SMA(DX, N)
 *
 * Characteristics:
 * - Quantifies trend strength (0‚Äì100), independent of direction.
 * - ADX < 20 ‚Üí weak trend; > 40 ‚Üí strong trend.
 *
 * Params:
 *   - period (int): smoothing period. Default = 14.
 */
class ADXIndicator extends BaseIndicator
{
    public string $name = 'adx';
    public string $displayName = 'Average Directional Index';
    public bool $multiSeries = true;

    public array $defaults = [
        'period' => 14,
    ];

    public function compute(array $bars, array $params = []): array
    {
        $bars = $this->normalizeBars($bars);
        $opts = $this->opts($params);
        $period = (int)$opts['period'];

        $n = count($bars);
        $tr = $plusDM = $minusDM = [];

        // Step 1: Compute TR, +DM, and -DM
        for ($i = 1; $i < $n; $i++) {
            $upMove = $bars[$i]['h'] - $bars[$i - 1]['h'];
            $downMove = $bars[$i - 1]['l'] - $bars[$i]['l'];
            $plusDM[] = ($upMove > $downMove && $upMove > 0) ? $upMove : 0;
            $minusDM[] = ($downMove > $upMove && $downMove > 0) ? $downMove : 0;
            $tr[] = max(
                $bars[$i]['h'] - $bars[$i]['l'],
                abs($bars[$i]['h'] - $bars[$i - 1]['c']),
                abs($bars[$i]['l'] - $bars[$i - 1]['c'])
            );
        }

        // Step 2: Compute smoothed DI and DX
        $rows = [];
        for ($i = $period - 1; $i < count($tr); $i++) {
            $trN = array_sum(array_slice($tr, $i - $period + 1, $period));
            $plusDIN = 100 * (array_sum(array_slice($plusDM, $i - $period + 1, $period)) / $trN);
            $minusDIN = 100 * (array_sum(array_slice($minusDM, $i - $period + 1, $period)) / $trN);
            $dx = ($plusDIN + $minusDIN) > 0 ? (abs($plusDIN - $minusDIN) / ($plusDIN + $minusDIN)) * 100 : 0;

            $rows[] = [
                't' => $bars[$i + 1]['t'],
                'indicator' => "adx_{$period}",
                'value' => round($dx, 6),
                'meta' => json_encode([
                    '+DI' => round($plusDIN, 6),
                    '-DI' => round($minusDIN, 6),
                ]),
            ];
        }

        return $rows;
    }
}app/Services/Compute/Indicators/BetaIndicator.php


===== FILE: app/Services/Compute/Indicators/BetaIndicator.php =====

<?php

namespace App\Services\Compute\Indicators;

use App\Services\Compute\BaseIndicator;

/**
 * BetaIndicator
 *
 * Computes the Beta coefficient of a stock relative to a benchmark index.
 *
 * Math summary:
 *   Beta = Covariance(stock_returns, benchmark_returns) / Variance(benchmark_returns)
 *
 * Characteristics:
 * - Measures sensitivity of a stock‚Äôs returns relative to market movement.
 * - Beta > 1: more volatile than market; < 1: less volatile.
 *
 * Params:
 *   - benchmark (array): benchmark series (e.g., S&P500 closes)
 *   - period (int): lookback window (default: 60)
 */
class BetaIndicator extends BaseIndicator
{
    public string $name = 'beta';
    public string $displayName = 'Beta Coefficient';
    public bool $multiSeries = false;

    public array $defaults = [
        'period' => 60,
    ];

    public function compute(array $bars, array $params = []): array
    {
        $bars = $this->normalizeBars($bars);
        $opts = $this->opts($params);
        $period = (int)$opts['period'];

        if (empty($params['beta']['benchmark'] ?? null)) {
            // No benchmark data ‚Üí skip computation
            return [];
        }

        $benchmark = $params['beta']['benchmark'];
        $closes = array_column($bars, 'c');
        $rows = [];

        // Compute daily returns
        $retStock = $this->returns($closes);
        $retBench = $this->returns($benchmark);

        for ($i = $period; $i < count($retStock); $i++) {
            $stockSlice = array_slice($retStock, $i - $period, $period);
            $benchSlice = array_slice($retBench, $i - $period, $period);

            $cov = $this->covariance($stockSlice, $benchSlice);
            $var = $this->variance($benchSlice);
            $beta = $var != 0 ? $cov / $var : null;

            if ($beta !== null) {
                $rows[] = [
                    't' => $bars[$i]['t'],
                    'indicator' => "beta_{$period}",
                    'value' => round($beta, 6),
                    'meta' => null,
                ];
            }
        }

        return $rows;
    }
}app/Services/Compute/Indicators/VWAPIndicator.php


===== FILE: app/Services/Compute/Indicators/VWAPIndicator.php =====

<?php

namespace App\Services\Compute\Indicators;

use App\Services\Compute\BaseIndicator;

/**
 * VWAPIndicator
 *
 * Computes the Volume Weighted Average Price (VWAP).
 *
 * For daily resolution:
 *   - If Polygon provides 'vw', we use it directly.
 *   - Otherwise, we approximate:
 *       VWAP_t = Œ£(P_typical_i * V_i) / Œ£(V_i)
 *       where P_typical = (H + L + C) / 3
 *
 * Characteristics:
 * - Represents the average price weighted by volume.
 * - Often used as intraday fair value benchmark.
 */
class VWAPIndicator extends BaseIndicator
{
    public string $name = 'vwap';
    public string $displayName = 'Volume Weighted Average Price';
    public array $defaults = [];

    public function compute(array $bars, array $params = []): array
    {
        $bars = $this->normalizeBars($bars);
        $outRows = [];

        $cumPV = 0.0; // cumulative price*volume
        $cumV  = 0.0; // cumulative volume

        foreach ($bars as $i => $b) {
            $v  = (float)($b['v'] ?? 0);
            $vw = $b['vw'] ?? null;

            if ($vw !== null) {
                // Polygon‚Äôs daily VWAP field available
                $val = (float)$vw;
            } else {
                // Compute from running average of typical price * volume
                $tp = ((float)$b['h'] + (float)$b['l'] + (float)$b['c']) / 3.0;
                $cumPV += $tp * $v;
                $cumV  += $v;
                $val = $cumV > 0 ? $cumPV / $cumV : null;
            }

            if ($val !== null) {
                $outRows[] = [
                    't' => $b['t'],
                    'indicator' => 'vwap',
                    'value' => $val,
                    'meta' => null,
                ];
            }
        }

        return $outRows;
    }
}app/Services/Compute/Indicators/EMAIndicator.php


===== FILE: app/Services/Compute/Indicators/EMAIndicator.php =====

<?php

namespace App\Services\Compute\Indicators;

use App\Services\Compute\BaseIndicator;

/**
 * EMAIndicator
 *
 * Computes exponential moving averages (EMA) on closing prices.
 *
 * Math summary:
 *   EMA_t = (C_t - EMA_{t-1}) * k + EMA_{t-1}, where k = 2 / (n + 1)
 *
 * Characteristics:
 * - Reacts faster than SMA by emphasizing recent prices.
 * - Common windows: 12, 26, 50, 200.
 * - Core component for MACD and trend-following systems.
 */
class EMAIndicator extends BaseIndicator
{
    public string $name = 'ema';
    public string $displayName = 'Exponential Moving Average';
    public array $defaults = [
        'windows' => [12, 26, 50, 200],
    ];

    public function compute(array $bars, array $params = []): array
    {
        $bars = $this->normalizeBars($bars);
        $opts = $this->opts($params);
        $windows = $opts['windows'];

        $closes = array_column($bars, 'c');
        $outRows = [];

        foreach ($windows as $w) {
            $series = $this->ema($closes, (int)$w);
            foreach ($series as $i => $val) {
                if ($val === null) continue;
                $outRows[] = [
                    't' => $bars[$i]['t'],
                    'indicator' => "ema_{$w}",
                    'value' => (float)$val,
                    'meta' => null,
                ];
            }
        }

        return $outRows;
    }
}app/Services/Compute/Indicators/SharpeRatioIndicator.php


===== FILE: app/Services/Compute/Indicators/SharpeRatioIndicator.php =====

<?php

namespace App\Services\Compute\Indicators;

use App\Services\Compute\BaseIndicator;

/**
 * SharpeRatioIndicator
 *
 * Computes the Sharpe Ratio ‚Äî a measure of risk-adjusted return.
 *
 * Math summary:
 *   Sharpe = (Mean(Returns) - RiskFreeRate) / StdDev(Returns)
 *
 * Characteristics:
 * - Evaluates reward per unit of volatility.
 * - Higher values indicate better risk-adjusted performance.
 *
 * Params:
 *   - period (int): rolling window (default: 60)
 *   - risk_free (float): annualized risk-free rate (default: 0.02)
 */
class SharpeRatioIndicator extends BaseIndicator
{
    public string $name = 'sharpe_ratio';
    public string $displayName = 'Sharpe Ratio';
    public bool $multiSeries = false;

    public array $defaults = [
        'period' => 60,
        'risk_free' => 0.02,
    ];

    public function compute(array $bars, array $params = []): array
    {
        $bars = $this->normalizeBars($bars);
        $opts = $this->opts($params);
        $period = (int)$opts['period'];
        $rf = (float)$opts['risk_free'];

        $closes = array_column($bars, 'c');
        $returns = $this->returns($closes);
        $rows = [];

        for ($i = $period; $i < count($returns); $i++) {
            $slice = array_slice($returns, $i - $period, $period);
            $mean = array_sum($slice) / count($slice);
            $std = $this->stddev($slice);
            $sharpe = $std != 0 ? ($mean - ($rf / 252)) / $std : null; // 252 trading days/year

            if ($sharpe !== null) {
                $rows[] = [
                    't' => $bars[$i]['t'],
                    'indicator' => "sharpe_{$period}",
                    'value' => round($sharpe, 6),
                    'meta' => json_encode(['mean_return' => $mean, 'std' => $std]),
                ];
            }
        }

        return $rows;
    }
}app/Services/Compute/Indicators/RollingCorrelationIndicator.php


===== FILE: app/Services/Compute/Indicators/RollingCorrelationIndicator.php =====

<?php

namespace App\Services\Compute\Indicators;

use App\Services\Compute\BaseIndicator;

/**
 * RollingCorrelationIndicator
 *
 * Computes the rolling Pearson correlation coefficient between
 * two price series (e.g., the ticker vs a benchmark like SPY).
 *
 * Formula:
 *   Corr_t = Cov(X_t, Y_t) / (œÉ_X * œÉ_Y)
 *
 * Characteristics:
 * - Measures co-movement between two return streams.
 * - Range: [-1, +1], where 1 = perfect positive correlation.
 * - Useful for pair-trading and sector alignment studies.
 *
 * Params:
 * - window: int   ‚Üí Rolling period (e.g., 20)
 * - benchmark: array<float> ‚Üí Optional benchmark close series (must align in length)
 */
class RollingCorrelationIndicator extends BaseIndicator
{
    public string $name = 'rolling_corr';
    public string $displayName = 'Rolling Correlation Coefficient';
    public bool $multiSeries = false;

    public array $defaults = [
        'window' => 20,
        'benchmark' => [],
    ];

    /**
     * Compute rolling correlation between the ticker‚Äôs closes and a benchmark.
     */
    public function compute(array $bars, array $params = []): array
    {
        $bars = $this->normalizeBars($bars);
        $opts = $this->opts($params);

        $window = (int)$opts['window'];
        $benchmark = $opts['benchmark'] ?? [];

        $closes = array_column($bars, 'c');

        // If no benchmark provided, correlation cannot be computed.
        if (empty($benchmark) || count($benchmark) < count($closes)) {
            return [];
        }

        // Compute daily returns
        $retStock = $this->returns($closes);
        $retBench = $this->returns($benchmark);

        // Align lengths
        $minCount = min(count($retStock), count($retBench));
        $retStock = array_slice($retStock, -$minCount);
        $retBench = array_slice($retBench, -$minCount);
        $bars = array_slice($bars, -$minCount);

        // Rolling correlation
        $corr = $this->rollingCorrelation($retStock, $retBench, $window);

        // Output rows
        $rows = [];
        foreach ($corr as $i => $val) {
            if ($val === null) continue;
            $rows[] = [
                't' => $bars[$i]['t'],
                'indicator' => 'rolling_corr_' . $window,
                'value' => (float)$val,
                'meta' => null,
            ];
        }

        return $rows;
    }
}app/Services/Compute/Indicators/MFIIndicator.php


===== FILE: app/Services/Compute/Indicators/MFIIndicator.php =====

<?php

namespace App\Services\Compute\Indicators;

use App\Services\Compute\BaseIndicator;

/**
 * MFIIndicator
 *
 * Computes the Money Flow Index ‚Äî a volume-weighted variant of RSI.
 *
 * Math summary:
 *   TP  = (High + Low + Close) / 3
 *   MF  = TP * Volume
 *   Positive MF = sum of MF on up days
 *   Negative MF = sum of MF on down days
 *   MFI = 100 - (100 / (1 + (PosMF / NegMF)))
 *
 * Characteristics:
 * - Identifies overbought/oversold conditions using both price and volume.
 * - Range: 0‚Äì100; >80 = overbought, <20 = oversold.
 *
 * Params:
 *   - period (int): lookback period (default: 14)
 */
class MFIIndicator extends BaseIndicator
{
    public string $name = 'mfi';
    public string $displayName = 'Money Flow Index';
    public bool $multiSeries = false;

    public array $defaults = [
        'period' => 14,
    ];

    public function compute(array $bars, array $params = []): array
    {
        $bars = $this->normalizeBars($bars);
        $opts = $this->opts($params);
        $period = (int)$opts['period'];

        $rows = [];
        $tp = array_map(fn($b) => ($b['h'] + $b['l'] + $b['c']) / 3, $bars);
        $mf = [];

        // Step 1: Compute Raw Money Flow (TP * Volume)
        foreach ($bars as $i => $b) {
            $mf[$i] = $tp[$i] * $b['v'];
        }

        // Step 2: Calculate MFI based on up/down price changes
        for ($i = $period; $i < count($bars); $i++) {
            $posMF = $negMF = 0;
            for ($j = $i - $period + 1; $j <= $i; $j++) {
                if ($tp[$j] > $tp[$j - 1]) {
                    $posMF += $mf[$j];
                } elseif ($tp[$j] < $tp[$j - 1]) {
                    $negMF += $mf[$j];
                }
            }

            $ratio = $negMF == 0 ? INF : ($posMF / $negMF);
            $mfi = 100 - (100 / (1 + $ratio));

            $rows[] = [
                't' => $bars[$i]['t'],
                'indicator' => "mfi_{$period}",
                'value' => round($mfi, 6),
                'meta' => json_encode(['pos_mf' => $posMF, 'neg_mf' => $negMF]),
            ];
        }

        return $rows;
    }
}app/Services/Compute/Indicators/MACDIndicator.php


===== FILE: app/Services/Compute/Indicators/MACDIndicator.php =====

<?php

namespace App\Services\Compute\Indicators;

use App\Services\Compute\BaseIndicator;

/**
 * MACDIndicator
 *
 * Computes the MACD oscillator ‚Äî difference between two EMAs of price.
 *
 * Math summary:
 *   MACD = EMA_fast(C) - EMA_slow(C)
 *   Signal = EMA(MACD, signal_period)
 *   Histogram = MACD - Signal
 *
 * Characteristics:
 * - Tracks the convergence/divergence of short vs long EMAs.
 * - Histogram visually represents momentum.
 * - Common settings: fast=12, slow=26, signal=9.
 */
class MACDIndicator extends BaseIndicator
{
    public string $name = 'macd';
    public string $displayName = 'Moving Average Convergence Divergence';
    public bool $multiSeries = true;

    public array $defaults = [
        'fast'   => 12,
        'slow'   => 26,
        'signal' => 9,
    ];

    public function compute(array $bars, array $params = []): array
    {
        $bars = $this->normalizeBars($bars);
        $opts = $this->opts($params);

        $fast = (int)$opts['fast'];
        $slow = (int)$opts['slow'];
        $sig  = (int)$opts['signal'];

        $closes = array_column($bars, 'c');

        // Compute fast and slow EMAs
        $emaFast = $this->ema($closes, $fast);
        $emaSlow = $this->ema($closes, $slow);

        $n = count($closes);
        $macd = array_fill(0, $n, null);

        // MACD = EMA_fast - EMA_slow
        for ($i = 0; $i < $n; $i++) {
            if ($emaFast[$i] === null || $emaSlow[$i] === null) continue;
            $macd[$i] = $emaFast[$i] - $emaSlow[$i];
        }

        // Determine first valid MACD index
        $startIdx = null;
        for ($i = 0; $i < $n; $i++) {
            if ($macd[$i] !== null) {
                $startIdx = $i;
                break;
            }
        }

        $signalArr = array_fill(0, $n, null);
        $histArr   = array_fill(0, $n, null);

        // Compute signal line (EMA of MACD) and histogram
        if ($startIdx !== null) {
            $macdValid = array_slice($macd, $startIdx);
            $sigSeries = $this->ema($macdValid, $sig);
            foreach ($sigSeries as $k => $sv) {
                $i = $k + $startIdx;
                if ($sv === null || $macd[$i] === null) continue;
                $signalArr[$i] = $sv;
                $histArr[$i]   = $macd[$i] - $sv;
            }
        }

        // Build output rows (MACD in value, signal/histo in meta)
        $outRows = [];
        for ($i = 0; $i < $n; $i++) {
            if ($macd[$i] === null) continue;
            $meta = json_encode([
                'signal'    => $signalArr[$i],
                'histogram' => $histArr[$i],
            ]);
            $outRows[] = [
                't' => $bars[$i]['t'],
                'indicator' => 'macd',
                'value' => (float)$macd[$i],
                'meta' => $meta,
            ];
        }

        return $outRows;
    }
}app/Services/Compute/Indicators/OBVIndicator.php


===== FILE: app/Services/Compute/Indicators/OBVIndicator.php =====

<?php

namespace App\Services\Compute\Indicators;

use App\Services\Compute\BaseIndicator;

/**
 * OBVIndicator
 *
 * Computes On-Balance Volume (OBV) ‚Äî a cumulative volume-based momentum indicator.
 *
 * Math summary:
 *   OBV(t) = OBV(t-1) + Volume(t)   if Close(t) > Close(t-1)
 *             OBV(t-1) - Volume(t)   if Close(t) < Close(t-1)
 *             OBV(t-1)               if Close(t) = Close(t-1)
 *
 * Characteristics:
 * - Measures buying/selling pressure as cumulative volume flow.
 * - Confirms price trends or warns of potential reversals.
 * - Often used alongside moving averages or divergences.
 */
class OBVIndicator extends BaseIndicator
{
    public string $name = 'obv';
    public string $displayName = 'On-Balance Volume';
    public bool $multiSeries = false;

    public function compute(array $bars, array $params = []): array
    {
        $bars = $this->normalizeBars($bars);
        $rows = [];

        $obv = 0.0;
        $prevClose = null;

        // Loop through each bar and accumulate OBV
        foreach ($bars as $i => $b) {
            if ($i === 0) {
                $prevClose = $b['c'];
                continue;
            }

            if ($b['c'] > $prevClose) {
                $obv += $b['v'];
            } elseif ($b['c'] < $prevClose) {
                $obv -= $b['v'];
            }

            $rows[] = [
                't' => $b['t'],
                'indicator' => 'obv',
                'value' => (float)$obv,
                'meta' => null,
            ];

            $prevClose = $b['c'];
        }

        return $rows;
    }
}app/Services/Compute/Indicators/DrawdownIndicator.php


===== FILE: app/Services/Compute/Indicators/DrawdownIndicator.php =====

<?php

namespace App\Services\Compute\Indicators;

use App\Services\Compute\BaseIndicator;

/**
 * DrawdownIndicator
 *
 * Computes the maximum drawdown ‚Äî the largest peak-to-trough decline over time.
 *
 * Math summary:
 *   Drawdown = (Peak - Current) / Peak
 *
 * Characteristics:
 * - Quantifies downside risk and volatility.
 * - Expressed as a fraction or percentage.
 *
 * Params:
 *   - none (computed cumulatively)
 */
class DrawdownIndicator extends BaseIndicator
{
    public string $name = 'drawdown';
    public string $displayName = 'Maximum Drawdown';
    public bool $multiSeries = false;

    public function compute(array $bars, array $params = []): array
    {
        $bars = $this->normalizeBars($bars);
        $rows = [];

        $peak = -INF;

        foreach ($bars as $b) {
            $peak = max($peak, $b['c']);
            $dd = $peak > 0 ? (($peak - $b['c']) / $peak) * 100 : 0;

            $rows[] = [
                't' => $b['t'],
                'indicator' => 'drawdown',
                'value' => round($dd, 6),
                'meta' => json_encode(['peak' => $peak]),
            ];
        }

        return $rows;
    }
}app/Services/Compute/Indicators/RollingBetaIndicator.php


===== FILE: app/Services/Compute/Indicators/RollingBetaIndicator.php =====

<?php

namespace App\Services\Compute\Indicators;

use App\Services\Compute\BaseIndicator;

/**
 * RollingBetaIndicator
 *
 * Computes the rolling beta of a stock relative to a benchmark index.
 *
 * Formula:
 *   Beta_t = Cov(returns_stock_t, returns_bench_t) / Var(returns_bench_t)
 *
 * Characteristics:
 * - Captures systematic risk over a rolling window.
 * - Beta > 1 ‚Üí stock is more volatile than benchmark.
 * - Beta < 1 ‚Üí stock moves less than benchmark.
 *
 * Params:
 * - window: int   ‚Üí Rolling period (default: 60 days)
 * - benchmark: array<float> ‚Üí Benchmark close series (must align in length)
 */
class RollingBetaIndicator extends BaseIndicator
{
    public string $name = 'rolling_beta';
    public string $displayName = 'Rolling Beta';
    public bool $multiSeries = false;

    public array $defaults = [
        'window' => 60,
        'benchmark' => [],
    ];

    public function compute(array $bars, array $params = []): array
    {
        $bars = $this->normalizeBars($bars);
        $opts = $this->opts($params);

        $window = (int)$opts['window'];
        $benchmark = $opts['benchmark'] ?? [];

        $closes = array_column($bars, 'c');
        if (empty($benchmark) || count($benchmark) < count($closes)) {
            return [];
        }

        // Compute returns for both
        $retStock = $this->returns($closes);
        $retBench = $this->returns($benchmark);

        $minCount = min(count($retStock), count($retBench));
        $retStock = array_slice($retStock, -$minCount);
        $retBench = array_slice($retBench, -$minCount);
        $bars = array_slice($bars, -$minCount);

        // Rolling beta
        $beta = $this->rollingBeta($retStock, $retBench, $window);

        $rows = [];
        foreach ($beta as $i => $val) {
            if ($val === null) continue;
            $rows[] = [
                't' => $bars[$i]['t'],
                'indicator' => 'rolling_beta_' . $window,
                'value' => (float)$val,
                'meta' => null,
            ];
        }

        return $rows;
    }
}app/Services/Compute/Indicators/RSIIndicator.php


===== FILE: app/Services/Compute/Indicators/RSIIndicator.php =====

<?php

namespace App\Services\Compute\Indicators;

use App\Services\Compute\BaseIndicator;

/**
 * RSIIndicator
 *
 * Computes the RSI (Relative Strength Index), a momentum oscillator.
 *
 * Math summary:
 *   RSI = 100 - [100 / (1 + RS)], where RS = avgGain / avgLoss
 *   Uses Wilder‚Äôs smoothing for avgGain/avgLoss.
 *
 * Characteristics:
 * - Bounded [0,100].
 * - Commonly interpreted as:
 *   - Overbought: RSI > 70
 *   - Oversold: RSI < 30
 * - Period 14 is the classical default.
 */
class RSIIndicator extends BaseIndicator
{
    public string $name = 'rsi';
    public string $displayName = 'Relative Strength Index';
    public array $defaults = [
        'period' => 14,
    ];

    public function compute(array $bars, array $params = []): array
    {
        $bars = $this->normalizeBars($bars);
        $opts = $this->opts($params);
        $p = (int)$opts['period'];

        $closes = array_column($bars, 'c');
        $series = $this->rsi($closes, $p);

        $outRows = [];
        foreach ($series as $i => $val) {
            if ($val === null) continue;
            $outRows[] = [
                't' => $bars[$i]['t'],
                'indicator' => "rsi_{$p}",
                'value' => (float)$val,
                'meta' => null,
            ];
        }
        return $outRows;
    }
}app/Services/Compute/Indicators/ATRIndicator.php


===== FILE: app/Services/Compute/Indicators/ATRIndicator.php =====

<?php

namespace App\Services\Compute\Indicators;

use App\Services\Compute\BaseIndicator;

/**
 * ATRIndicator
 *
 * Computes the Average True Range ‚Äî a measure of volatility.
 *
 * Math summary:
 *   TR_t = max(High_t - Low_t, |High_t - Close_{t-1}|, |Low_t - Close_{t-1}|)
 *   ATR_t = (ATR_{t-1} * (n - 1) + TR_t) / n  (Wilder‚Äôs smoothing)
 *
 * Characteristics:
 * - Captures both intraday and gap volatility.
 * - Unbounded ‚Äî higher values = higher volatility.
 * - Common period: 14.
 */
class ATRIndicator extends BaseIndicator
{
    public string $name = 'atr';
    public string $displayName = 'Average True Range';
    public array $defaults = [
        'period' => 14,
        'wilder' => true,
    ];

    public function compute(array $bars, array $params = []): array
    {
        $bars = $this->normalizeBars($bars);
        $opts = $this->opts($params);
        $p = (int)$opts['period'];

        $highs  = array_column($bars, 'h');
        $lows   = array_column($bars, 'l');
        $closes = array_column($bars, 'c');

        $tr = $this->trueRangeSeries($highs, $lows, $closes);
        $n  = count($tr);
        $atr = array_fill(0, $n, null);

        if ($n === 0 || $p <= 0) return [];

        // Wilder‚Äôs ATR smoothing: recursive moving average
        $sum = 0.0;
        for ($i = 0; $i < $n; $i++) {
            if ($i < $p) {
                $sum += (float)$tr[$i];
                if ($i === $p - 1) $atr[$i] = $sum / $p;
            } else {
                $atr[$i] = (($atr[$i - 1] * ($p - 1)) + (float)$tr[$i]) / $p;
            }
        }

        // Build output rows
        $outRows = [];
        foreach ($atr as $i => $val) {
            if ($val === null) continue;
            $outRows[] = [
                't' => $bars[$i]['t'],
                'indicator' => "atr_{$p}",
                'value' => (float)$val,
                'meta' => null,
            ];
        }

        return $outRows;
    }
}app/Services/Compute/Indicators/SMAIndicator.php


===== FILE: app/Services/Compute/Indicators/SMAIndicator.php =====

<?php

namespace App\Services\Compute\Indicators;

use App\Services\Compute\BaseIndicator;

/**
 * SMAIndicator
 *
 * Computes simple moving averages (SMA) over closing prices.
 *
 * Math summary:
 *   SMA_t = (C_t + C_{t-1} + ... + C_{t-n+1}) / n
 *
 * Characteristics:
 * - Non-exponential, equal-weighted moving average.
 * - Smoother than raw price, but slower to react.
 * - Often used for support/resistance and trend confirmation.
 *
 * Extendability:
 * - Supports multiple windows (20, 50, 200 by default).
 * - Each window generates its own indicator series: "sma_20", "sma_50", etc.
 */
class SMAIndicator extends BaseIndicator
{
    public string $name = 'sma';
    public string $displayName = 'Simple Moving Average';
    public array $defaults = [
        'windows' => [20, 50, 200],
    ];

    public function compute(array $bars, array $params = []): array
    {
        // Normalize bar order to ascending timestamps
        $bars = $this->normalizeBars($bars);

        // Merge runtime params (from CLI/queue) with module defaults
        $opts = $this->opts($params);
        $windows = $opts['windows'];

        // Extract closing prices from bar data
        $closes = array_column($bars, 'c');
        $outRows = [];

        // For each requested window, compute SMA and produce one record per valid bar
        foreach ($windows as $w) {
            $series = $this->rollingMean($closes, (int)$w);
            foreach ($series as $i => $val) {
                if ($val === null) continue; // skip until enough bars exist
                $outRows[] = [
                    't' => $bars[$i]['t'],
                    'indicator' => "sma_{$w}",
                    'value' => (float)$val,
                    'meta' => null,
                ];
            }
        }

        return $outRows;
    }
}app/Services/Compute/Indicators/BollingerIndicator.php


===== FILE: app/Services/Compute/Indicators/BollingerIndicator.php =====

<?php

namespace App\Services\Compute\Indicators;

use App\Services\Compute\BaseIndicator;

/**
 * BollingerIndicator
 *
 * Computes Bollinger Bands around a simple moving average.
 *
 * Math summary:
 *   Mid  = SMA(C, period)
 *   Std  = rolling standard deviation(C, period)
 *   Upper = Mid + k * Std
 *   Lower = Mid - k * Std
 *
 * Characteristics:
 * - Dynamic volatility envelope.
 * - k = 2 (2œÉ) captures ~95% of price action statistically.
 * - Squeezes = low volatility, Breakouts = high volatility.
 */
class BollingerIndicator extends BaseIndicator
{
    public string $name = 'bb';
    public string $displayName = 'Bollinger Bands';
    public bool $multiSeries = true;

    public array $defaults = [
        'period' => 20,
        'stdevs' => 2.0,
    ];

    public function compute(array $bars, array $params = []): array
    {
        $bars = $this->normalizeBars($bars);
        $opts = $this->opts($params);
        $p = (int)$opts['period'];
        $k = (float)$opts['stdevs'];

        $closes = array_column($bars, 'c');
        $sma  = $this->rollingMean($closes, $p);
        $std  = $this->rollingStd($closes, $p);

        $outRows = [];
        foreach ($closes as $i => $_) {
            if ($sma[$i] === null || $std[$i] === null) continue;
            $mid = $sma[$i];
            $upper = $mid + $k * $std[$i];
            $lower = $mid - $k * $std[$i];
            $meta = json_encode([
                'mid'   => $mid,
                'upper' => $upper,
                'lower' => $lower,
                'stdev' => $std[$i],
            ]);
            $outRows[] = [
                't' => $bars[$i]['t'],
                'indicator' => "bb_{$p}_{$k}",
                'value' => (float)$mid,
                'meta' => $meta,
            ];
        }
        return $outRows;
    }
}app/Services/Compute/Indicators/R2Indicator.php


===== FILE: app/Services/Compute/Indicators/R2Indicator.php =====

<?php

namespace App\Services\Compute\Indicators;

use App\Services\Compute\BaseIndicator;

/**
 * R2Indicator
 *
 * Computes the rolling coefficient of determination (R¬≤) between
 * a ticker‚Äôs returns and a benchmark‚Äôs returns.
 *
 * Formula:
 *   R¬≤_t = Corr(X_t, Y_t)^2
 *
 * Interpretation:
 * - Measures how much of a stock‚Äôs variance is explained by the benchmark.
 * - R¬≤ near 1 means highly benchmark-driven; near 0 means idiosyncratic.
 *
 * Params:
 * - window: int   ‚Üí Rolling period (e.g., 60 days)
 * - benchmark: array<float> ‚Üí Benchmark close series
 */
class R2Indicator extends BaseIndicator
{
    public string $name = 'r2';
    public string $displayName = 'Rolling R¬≤ (Coefficient of Determination)';
    public bool $multiSeries = false;

    public array $defaults = [
        'window' => 60,
        'benchmark' => [],
    ];

    public function compute(array $bars, array $params = []): array
    {
        $bars = $this->normalizeBars($bars);
        $opts = $this->opts($params);

        $window = (int)$opts['window'];
        $benchmark = $opts['benchmark'] ?? [];

        $closes = array_column($bars, 'c');
        if (empty($benchmark) || count($benchmark) < count($closes)) {
            return [];
        }

        // Compute returns and align
        $retStock = $this->returns($closes);
        $retBench = $this->returns($benchmark);
        $minCount = min(count($retStock), count($retBench));
        $retStock = array_slice($retStock, -$minCount);
        $retBench = array_slice($retBench, -$minCount);
        $bars = array_slice($bars, -$minCount);

        // Rolling correlation ‚Üí R¬≤ = Corr¬≤
        $corr = $this->rollingCorrelation($retStock, $retBench, $window);

        $rows = [];
        foreach ($corr as $i => $val) {
            if ($val === null) continue;
            $rows[] = [
                't' => $bars[$i]['t'],
                'indicator' => 'r2_' . $window,
                'value' => pow((float)$val, 2),
                'meta' => null,
            ];
        }

        return $rows;
    }
}app/Services/Compute/Indicators/StochasticIndicator.php


===== FILE: app/Services/Compute/Indicators/StochasticIndicator.php =====

<?php

namespace App\Services\Compute\Indicators;

use App\Services\Compute\BaseIndicator;

/**
 * StochasticIndicator
 *
 * Computes the Stochastic Oscillator ‚Äî a momentum indicator comparing
 * the current close to a range of recent highs/lows.
 *
 * Math summary:
 *   %K = 100 * (Close - LowestLow(N)) / (HighestHigh(N) - LowestLow(N))
 *   %D = SMA(%K, 3)
 *
 * Characteristics:
 * - Measures overbought/oversold conditions (0‚Äì100 scale).
 * - %K is the fast line; %D (3-period SMA) is the signal line.
 * - Common parameters: period = 14.
 *
 * Params:
 *   - period (int): lookback for %K. Default = 14.
 */
class StochasticIndicator extends BaseIndicator
{
    public string $name = 'stochastic';
    public string $displayName = 'Stochastic Oscillator';
    public bool $multiSeries = true;

    public array $defaults = [
        'period' => 14,
    ];

    public function compute(array $bars, array $params = []): array
    {
        $bars = $this->normalizeBars($bars);
        $opts = $this->opts($params);
        $period = (int)$opts['period'];

        $n = count($bars);
        $kArr = [];
        $rows = [];

        // Compute %K line
        for ($i = $period - 1; $i < $n; $i++) {
            $window = array_slice($bars, $i - $period + 1, $period);
            $highs = array_column($window, 'h');
            $lows  = array_column($window, 'l');
            $close = $bars[$i]['c'];

            $highN = max($highs);
            $lowN  = min($lows);
            $k = ($highN - $lowN) != 0 ? 100 * (($close - $lowN) / ($highN - $lowN)) : 0;
            $kArr[$i] = $k;

            $rows[] = [
                't' => $bars[$i]['t'],
                'indicator' => "stoch_k_{$period}",
                'value' => round($k, 6),
                'meta' => null,
            ];
        }

        // Compute %D (3-period SMA of %K)
        $dRows = [];
        $dPeriod = 3;
        for ($i = $period - 1 + $dPeriod - 1; $i < $n; $i++) {
            $slice = array_slice($kArr, $i - $dPeriod + 1, $dPeriod, true);
            $avg = array_sum($slice) / count($slice);
            $dRows[] = [
                't' => $bars[$i]['t'],
                'indicator' => "stoch_d_{$period}",
                'value' => round($avg, 6),
                'meta' => null,
            ];
        }

        return array_merge($rows, $dRows);
    }
}app/Services/Compute/Indicators/CCIIndicator.php


===== FILE: app/Services/Compute/Indicators/CCIIndicator.php =====

<?php

namespace App\Services\Compute\Indicators;

use App\Services\Compute\BaseIndicator;

/**
 * CCIIndicator
 *
 * Computes the Commodity Channel Index ‚Äî a measure of how far the typical price
 * has diverged from its statistical mean.
 *
 * Math summary:
 *   TP = (High + Low + Close) / 3
 *   CCI = (TP - SMA(TP, N)) / (0.015 * MeanDeviation(TP, N))
 *
 * Characteristics:
 * - Values above +100 suggest overbought; below -100 suggest oversold.
 * - More responsive than RSI to short-term price volatility.
 *
 * Params:
 *   - period (int): lookback period. Default = 20.
 */
class CCIIndicator extends BaseIndicator
{
    public string $name = 'cci';
    public string $displayName = 'Commodity Channel Index';
    public bool $multiSeries = false;

    public array $defaults = [
        'period' => 20,
    ];

    public function compute(array $bars, array $params = []): array
    {
        $bars = $this->normalizeBars($bars);
        $opts = $this->opts($params);
        $period = (int)$opts['period'];

        // Compute Typical Price (TP)
        $tp = array_map(fn($b) => ($b['h'] + $b['l'] + $b['c']) / 3, $bars);
        $rows = [];

        // For each bar after enough history, compute CCI
        for ($i = $period - 1; $i < count($tp); $i++) {
            $slice = array_slice($tp, $i - $period + 1, $period);
            $sma = array_sum($slice) / $period;

            // Mean deviation of typical price
            $meanDev = array_sum(array_map(fn($v) => abs($v - $sma), $slice)) / $period;
            $cci = $meanDev != 0 ? ($tp[$i] - $sma) / (0.015 * $meanDev) : 0;

            $rows[] = [
                't' => $bars[$i]['t'],
                'indicator' => "cci_{$period}",
                'value' => round($cci, 6),
                'meta' => null,
            ];
        }

        return $rows;
    }
}app/Services/Compute/Indicators/MomentumIndicator.php


===== FILE: app/Services/Compute/Indicators/MomentumIndicator.php =====

<?php

namespace App\Services\Compute\Indicators;

use App\Services\Compute\BaseIndicator;

/**
 * ============================================================================
 *  MomentumIndicator
 * ============================================================================
 *
 * Computes the **momentum** of price over one or more configurable lookback windows.
 *
 * Formula (absolute mode):
 *   Momentum = Close(t) - Close(t - N)
 *
 * Formula (percentage mode, if `percent` param = true):
 *   Momentum = ((Close(t) / Close(t - N)) - 1) * 100
 *
 * Interpretation:
 * - Positive ‚Üí upward acceleration (bullish)
 * - Negative ‚Üí downward acceleration (bearish)
 * - Near zero ‚Üí neutral or consolidating trend
 *
 * Features:
 * - Supports multiple window configurations (e.g., 10, 20, 50).
 * - Compatible with hybrid data storage (ticker_indicators + snapshots).
 * - Returns per-window indicator records using standard key format: momentum_{N}.
 *
 * ============================================================================
 */
class MomentumIndicator extends BaseIndicator
{
    /** @var string Unique short name */
    public string $name = 'momentum';

    /** @var string Human-readable display name */
    public string $displayName = 'Momentum';

    /** @var bool Whether this indicator produces multiple keyed outputs */
    public bool $multiSeries = false;

    /** @var array Default parameters */
    public array $defaults = [
        'window'  => 10,        // primary lookback period
        'period'  => 10,        // alias for backward compatibility
        'windows' => [10],      // allow multiple simultaneous computations
        'percent' => false,     // true = percentage change mode
    ];

    /**
     * Compute one or more momentum series from OHLCV bar data.
     *
     * @param  array $bars   Normalized OHLCV data (ascending by date)
     * @param  array $params Optional runtime parameters
     * @return array         Array of ['t','indicator','value','meta'] rows
     */
    public function compute(array $bars, array $params = []): array
    {
        // Normalize and merge options
        $bars = $this->normalizeBars($bars);
        $opts = $this->opts($params);

        // üîß Resolve lookback windows
        $window = (int)($opts['window'] ?? $opts['period'] ?? 10);
        $windows = (array)($opts['windows'] ?? [$window]);
        $percent = (bool)($opts['percent'] ?? false);

        $closes = array_column($bars, 'c');
        $rows   = [];

        foreach ($windows as $win) {
            $win = (int)$win;
            if ($win <= 0 || count($closes) <= $win) {
                continue;
            }

            for ($i = $win; $i < count($closes); $i++) {
                $prev = $closes[$i - $win];
                $curr = $closes[$i];

                if ($prev === 0.0 || $prev === null) {
                    $value = null;
                } else {
                    $value = $percent
                        ? (($curr / $prev) - 1) * 100
                        : ($curr - $prev);
                }

                $rows[] = [
                    't'         => $bars[$i]['t'],
                    'indicator' => "momentum_{$win}",
                    'value'     => $value !== null ? round($value, 6) : null,
                    'meta'      => null,
                ];
            }
        }

        return $rows;
    }
}app/Services/Compute/Registry.php


===== FILE: app/Services/Compute/Registry.php =====

<?php

namespace App\Services\Compute;

use App\Services\Compute\Indicators\SMAIndicator;
use App\Services\Compute\Indicators\EMAIndicator;
use App\Services\Compute\Indicators\RSIIndicator;
use App\Services\Compute\Indicators\MACDIndicator;
use App\Services\Compute\Indicators\ATRIndicator;
use App\Services\Compute\Indicators\BollingerIndicator;
use App\Services\Compute\Indicators\VWAPIndicator;
use App\Services\Compute\Indicators\MomentumIndicator;
use App\Services\Compute\Indicators\StochasticIndicator;
use App\Services\Compute\Indicators\CCIIndicator;
use App\Services\Compute\Indicators\ADXIndicator;
use App\Services\Compute\Indicators\OBVIndicator;
use App\Services\Compute\Indicators\MFIIndicator;
use App\Services\Compute\Indicators\BetaIndicator;
use App\Services\Compute\Indicators\SharpeRatioIndicator;
use App\Services\Compute\Indicators\DrawdownIndicator;
use App\Services\Compute\Indicators\VolatilityIndicator;
use App\Services\Compute\Indicators\RollingCorrelationIndicator;
use App\Services\Compute\Indicators\RollingBetaIndicator;
use App\Services\Compute\Indicators\R2Indicator;

/**
 * Class Registry
 *
 * Central registry that declares which indicator modules are currently active.
 *
 * Responsibilities:
 * - Acts as a discovery hub for all computational indicators.
 * - Decouples pipeline orchestration (FeaturePipeline) from specific implementations.
 * - Makes it simple to add, remove, or toggle entire indicator classes.
 * - Provides dynamic lookup of indicators via their `$name` property.
 *
 * Extending the registry:
 * - When adding a new indicator file under Compute/Indicators, import and append it to activeIndicators().
 * - Use descriptive `displayName` in indicator classes for clarity in logs/UI.
 */
class Registry
{
    /**
     * Return all active indicator module instances.
     *
     * Note:
     * - Each module is stateless; new instances can be safely reused.
     * - You can disable modules by commenting them out if you want
     *   to temporarily remove them from the pipeline.
     *
     * @return array<BaseIndicator>
     */
    public static function activeIndicators(): array
    {
        return [
            // Core trend and moving average indicators
            new SMAIndicator(),
            new EMAIndicator(),
            new RSIIndicator(),
            new MACDIndicator(),
            new ATRIndicator(),
            new BollingerIndicator(),
            new VWAPIndicator(),
            new RollingCorrelationIndicator(),
            new RollingBetaIndicator(),
            new R2Indicator(),

            // Momentum / Oscillator family
            new MomentumIndicator(),
            new StochasticIndicator(),
            new CCIIndicator(),
            new ADXIndicator(),

            // Volume-based indicators
            new OBVIndicator(),
            new MFIIndicator(),

            // Risk and market-relative indicators
            new BetaIndicator(),
            new SharpeRatioIndicator(),
            new DrawdownIndicator(),
            new VolatilityIndicator(),
        ];
    }

    /**
     * Select a subset of indicators by short name.
     *
     * Example:
     *   Registry::select(['sma', 'rsi', 'macd']);
     *
     * Returns:
     *   [ SMAIndicator, RSIIndicator, MACDIndicator ]
     *
     * Behavior:
     * - Ignores unknown names to ensure pipeline safety.
     * - Case-insensitive and whitespace-tolerant.
     *
     * @param array<string> $names
     * @return array<BaseIndicator>
     */
    public static function select(array $names): array
    {
        $map = [];
        foreach (self::activeIndicators() as $mod) {
            $map[strtolower($mod->name)] = $mod;
        }

        $out = [];
        foreach ($names as $name) {
            $k = strtolower(trim($name));
            if (isset($map[$k])) {
                $out[] = $map[$k];
            }
        }

        return $out;
    }
}app/Services/Compute/BaseIndicator.php


===== FILE: app/Services/Compute/BaseIndicator.php =====

<?php

namespace App\Services\Compute;

use Illuminate\Support\Facades\Log;
use Carbon\Carbon;

/**
 * Class BaseIndicator
 *
 * The abstract base for all indicator modules.
 *
 * Responsibilities:
 * - Provide a stable interface for computing indicators from OHLCV bars.
 * - Offer common math/statistical utilities (SMA, EMA, RSI pieces, rolling stdev, True Range, etc.).
 * - Normalize/prepare bar inputs and merge module defaults with runtime params.
 * - Bar normalization (ensures consistent structure for OHLCV data)
 * - Provide shared math and statistical utilities.
 * - Offer rolling-window tools for advanced financial analytics.
 * - Parameter merging (`opts()`)
 *
 * Contract:
 * - Child classes must implement compute(array $bars, array $params = []): array
 * - compute() returns an array of "rows" (ready to upsert), each row:
 *   [
 *     't'         => 'YYYY-MM-DD HH:MM:SS',
 *     'indicator' => 'sma_20' (or similar),
 *     'value'     => float|null, // the main series value for that indicator at time t
 *     'meta'      => ?string,    // optional JSON string for auxiliary series (e.g., MACD signal/histogram)
 *   ]
 *
 * Design goals:
 * - Keep computation modules clean and math-focused.
 * - Indicators remain math-only and stateless.
 * - No DB or API calls at this layer.
 * - Consistent time alignment and normalized bar inputs.
 * - Provide reusable helpers for time-series operations.
 * - All derived classes must define:
 *      public string $name;
 *      public string $displayName;
 *      public bool $multiSeries;
 *      public array  $defaults;
 * 
 * Notes:
 * - Keep heavy math stateless and pure; avoid DB access here.
 * - Logging is minimal at this layer; orchestration logs live in pipeline/job/command.
 */

abstract class BaseIndicator
{
    /** @var string Short name of indicator (e.g., 'sma', 'rsi', 'macd'). */
    public string $name;

    /** @var string Human-readable display name. */
    public string $displayName = '';

    /** @var array Default parameters for this indicator. */
    public array $defaults = [];

    /** @var bool Whether this indicator outputs multiple sub-series. */
    public bool $multiSeries = false;

    /* ======================================================================
     * ABSTRACT CONTRACT
     * ====================================================================== */

    /**
     * Compute normalized indicator rows for upsert.
     *
     * @param array<int, array{t:string,o:?float,h:?float,l:?float,c:?float,v:?float,vw:?float}> $bars
     * @param array $params
     * @return array<int, array{t:string,indicator:string,value:?float,meta:?string}>
     */
    abstract public function compute(array $bars, array $params = []): array;

    /* ======================================================================
     * CORE NORMALIZATION UTILITIES
     * ====================================================================== */

    protected function opts(array $params): array
    {
        return array_replace_recursive($this->defaults, $params[$this->name] ?? []);
    }

    protected function normalizeBars(array $bars): array
    {
        usort($bars, fn($a, $b) => strcmp($a['t'], $b['t']));
        return $bars;
    }

    /* ======================================================================
     * COMMON MATH / STAT HELPERS
     * ====================================================================== */

    /** Rolling simple moving average (SMA). */
    protected function rollingMean(array $values, int $window): array
    {
        $n = count($values);
        $out = array_fill(0, $n, null);
        if ($window <= 0 || $window > $n) return $out;

        $sum = 0.0;
        for ($i = 0; $i < $n; $i++) {
            $sum += (float)($values[$i] ?? 0.0);
            if ($i >= $window) $sum -= (float)($values[$i - $window] ?? 0.0);
            if ($i >= $window - 1) $out[$i] = $sum / $window;
        }
        return $out;
    }

    /** Exponential Moving Average (EMA). */
    protected function ema(array $values, int $window): array
    {
        $n = count($values);
        $out = array_fill(0, $n, null);
        if ($window <= 0 || $window > $n) return $out;

        $sum = array_sum(array_slice($values, 0, $window));
        $emaPrev = $sum / $window;
        $out[$window - 1] = $emaPrev;

        $k = 2 / ($window + 1);
        for ($i = $window; $i < $n; $i++) {
            $price = (float)($values[$i] ?? 0.0);
            $emaPrev = ($price - $emaPrev) * $k + $emaPrev;
            $out[$i] = $emaPrev;
        }
        return $out;
    }

    /** RSI (Relative Strength Index) using Wilder‚Äôs method. */
    protected function rsi(array $closes, int $period): array
    {
        $n = count($closes);
        $out = array_fill(0, $n, null);
        if ($period <= 0 || $period >= $n) return $out;

        $gains = [];
        $losses = [];
        for ($i = 1; $i < $n; $i++) {
            $delta = (float)($closes[$i] ?? 0.0) - (float)($closes[$i - 1] ?? 0.0);
            $gains[$i] = $delta > 0 ? $delta : 0.0;
            $losses[$i] = $delta < 0 ? -$delta : 0.0;
        }

        $avgGain = array_sum(array_slice($gains, 1, $period)) / $period;
        $avgLoss = array_sum(array_slice($losses, 1, $period)) / $period;

        $out[$period] = $avgLoss == 0.0 ? 100.0 : 100.0 - (100.0 / (1.0 + ($avgGain / $avgLoss)));

        for ($i = $period + 1; $i < $n; $i++) {
            $avgGain = (($avgGain * ($period - 1)) + ($gains[$i] ?? 0.0)) / $period;
            $avgLoss = (($avgLoss * ($period - 1)) + ($losses[$i] ?? 0.0)) / $period;
            $out[$i] = $avgLoss == 0.0 ? 100.0 : 100.0 - (100.0 / (1.0 + ($avgGain / $avgLoss)));
        }
        return $out;
    }

    /** Rolling population standard deviation. */
    protected function rollingStd(array $values, int $window): array
    {
        $n = count($values);
        $out = array_fill(0, $n, null);
        if ($window <= 1 || $window > $n) return $out;

        $sum = 0.0;
        $sumSq = 0.0;
        for ($i = 0; $i < $n; $i++) {
            $x = (float)($values[$i] ?? 0.0);
            $sum += $x;
            $sumSq += $x * $x;

            if ($i >= $window) {
                $xrm = (float)($values[$i - $window] ?? 0.0);
                $sum -= $xrm;
                $sumSq -= $xrm * $xrm;
            }

            if ($i >= $window - 1) {
                $mean = $sum / $window;
                $var = max(0.0, ($sumSq / $window) - ($mean * $mean));
                $out[$i] = sqrt($var);
            }
        }
        return $out;
    }

    /** True Range (for ATR). */
    protected function trueRangeSeries(array $highs, array $lows, array $closes): array
    {
        $n = count($highs);
        $tr = array_fill(0, $n, null);
        for ($i = 0; $i < $n; $i++) {
            $h = (float)($highs[$i] ?? 0.0);
            $l = (float)($lows[$i] ?? 0.0);
            $cPrev = $i > 0 ? (float)($closes[$i - 1] ?? 0.0) : null;
            $tr[$i] = max($h - $l, $cPrev !== null ? abs($h - $cPrev) : 0.0, $cPrev !== null ? abs($l - $cPrev) : 0.0);
        }
        return $tr;
    }

    /* ======================================================================
     * EXTENDED STATISTICS
     * ====================================================================== */

    protected function returns(array $closes): array
    {
        $returns = [];
        for ($i = 1; $i < count($closes); $i++) {
            $prev = (float)($closes[$i - 1] ?? 0.0);
            $curr = (float)($closes[$i] ?? 0.0);
            $returns[] = ($prev == 0.0) ? 0.0 : ($curr - $prev) / $prev;
        }
        return $returns;
    }

    protected function variance(array $values): float
    {
        $values = array_filter($values, fn($v) => is_numeric($v));
        $n = count($values);
        if ($n === 0) return 0.0;
        $mean = array_sum($values) / $n;
        $sumSq = 0.0;
        foreach ($values as $v) $sumSq += ($v - $mean) ** 2;
        return $sumSq / $n;
    }

    protected function stddev(array $values): float
    {
        return sqrt($this->variance($values));
    }

    protected function covariance(array $x, array $y): float
    {
        $n = min(count($x), count($y));
        if ($n === 0) return 0.0;

        $x = array_slice($x, 0, $n);
        $y = array_slice($y, 0, $n);

        $meanX = array_sum($x) / $n;
        $meanY = array_sum($y) / $n;

        $sum = 0.0;
        for ($i = 0; $i < $n; $i++) $sum += ($x[$i] - $meanX) * ($y[$i] - $meanY);
        return $sum / $n;
    }

    /* ======================================================================
     * GENERIC ROLLING UTILITIES
     * ====================================================================== */

    protected function rollingApply(array $values, int $window, callable $callback): array
    {
        $n = count($values);
        $out = array_fill(0, $n, null);
        if ($window <= 0 || $window > $n) return $out;

        for ($i = $window - 1; $i < $n; $i++) {
            $slice = array_slice($values, $i - $window + 1, $window);
            $slice = array_filter($slice, fn($v) => is_numeric($v));
            $out[$i] = !empty($slice) ? $callback($slice) : null;
        }

        return $out;
    }

    protected function rollingMeanStd(array $values, int $window): array
    {
        $n = count($values);
        $mean = array_fill(0, $n, null);
        $std = array_fill(0, $n, null);
        if ($window <= 1 || $window > $n) return compact('mean', 'std');

        $sum = 0.0;
        $sumSq = 0.0;

        for ($i = 0; $i < $n; $i++) {
            $x = (float)($values[$i] ?? 0.0);
            $sum += $x;
            $sumSq += $x * $x;

            if ($i >= $window) {
                $xrm = (float)($values[$i - $window] ?? 0.0);
                $sum -= $xrm;
                $sumSq -= $xrm * $xrm;
            }

            if ($i >= $window - 1) {
                $mean[$i] = $sum / $window;
                $var = max(0.0, ($sumSq / $window) - ($mean[$i] * $mean[$i]));
                $std[$i] = sqrt($var);
            }
        }

        return compact('mean', 'std');
    }

    /* ======================================================================
     * ADVANCED ROLLING METRICS
     * ====================================================================== */

    /**
     * Rolling correlation between two time series.
     * 
     * Corr_t = Cov(X_t, Y_t) / (œÉ_X * œÉ_Y)
     */
    protected function rollingCorrelation(array $x, array $y, int $window): array
    {
        $n = min(count($x), count($y));
        $out = array_fill(0, $n, null);
        if ($window <= 1 || $window > $n) return $out;

        for ($i = $window - 1; $i < $n; $i++) {
            $xSlice = array_slice($x, $i - $window + 1, $window);
            $ySlice = array_slice($y, $i - $window + 1, $window);

            $cov = $this->covariance($xSlice, $ySlice);
            $stdX = $this->stddev($xSlice);
            $stdY = $this->stddev($ySlice);

            $out[$i] = ($stdX > 0 && $stdY > 0) ? $cov / ($stdX * $stdY) : null;
        }

        return $out;
    }

    /**
     * Rolling beta: slope of regression of X (stock) vs Y (benchmark).
     * 
     * Beta_t = Cov(X_t, Y_t) / Var(Y_t)
     */
    protected function rollingBeta(array $x, array $y, int $window): array
    {
        $n = min(count($x), count($y));
        $out = array_fill(0, $n, null);
        if ($window <= 1 || $window > $n) return $out;

        for ($i = $window - 1; $i < $n; $i++) {
            $xSlice = array_slice($x, $i - $window + 1, $window);
            $ySlice = array_slice($y, $i - $window + 1, $window);

            $varY = $this->variance($ySlice);
            $covXY = $this->covariance($xSlice, $ySlice);

            $out[$i] = ($varY > 0) ? $covXY / $varY : null;
        }

        return $out;
    }

    /* ======================================================================
     * TIMESTAMP NORMALIZATION
     * ====================================================================== */

    protected function toTimestampString($t): string
    {
        if ($t instanceof \DateTimeInterface) return $t->format('Y-m-d H:i:s');
        if (is_numeric($t)) return Carbon::createFromTimestamp((int)$t)->toDateTimeString();
        return (string)$t;
    }
}app/Services/Compute/FeaturePipeline.php


===== FILE: app/Services/Compute/FeaturePipeline.php =====

<?php

namespace App\Services\Compute;

use App\Models\Ticker;
use App\Models\TickerPriceHistory;
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;
use Carbon\Carbon;

/**
 * ============================================================================
 *  FeaturePipeline
 * ============================================================================
 *
 * üîß Purpose:
 *   The FeaturePipeline acts as the **hybrid computation orchestrator** for
 *   TickerWolf‚Äôs analytical engine. It coordinates:
 *     ‚Ä¢ Retrieval of OHLCV bars (daily price/volume data)
 *     ‚Ä¢ Execution of indicator modules (SMA, MACD, Momentum, etc.)
 *     ‚Ä¢ Intelligent routing of results to storage layers:
 *         - Core DB layer      ‚Üí ticker_indicators
 *         - Snapshot JSON layer‚Üí ticker_feature_snapshots
 *         - Cache layer        ‚Üí in-memory via Laravel Cache
 *
 * üß† Design Philosophy:
 *   - Each indicator is computed **once per run**; outputs are routed to all
 *     relevant destinations (DB, cache, snapshot) according to config policy.
 *   - The pipeline dynamically adapts to indicator definitions declared in
 *     `config/indicators.php`.
 *   - Multi-window indicators (e.g., SMA_50, Momentum_10) are auto-parsed.
 *   - The system enforces consistent parameter normalization (`period` ‚áÑ `window`).
 *
 * ‚öôÔ∏è Invocation Contexts:
 *   - Called by `BuildTickerSnapshotJob` / `TickersComputeIndicators` / others.
 *   - Safe for parallel execution inside Bus::batch().
 *
 * ============================================================================
 */
class FeaturePipeline
{
    /**
     * Execute the hybrid computation pipeline for a single ticker.
     *
     * @param  int            $tickerId        Database ID of the ticker
     * @param  array<string>  $indicatorNames  Optional list of indicator names
     * @param  array{from?:string,to?:string} $range Date range filter (ISO8601)
     * @param  array          $params          Per-module runtime parameter overrides
     * @param  bool           $writeCoreToDb   Persist outputs to ticker_indicators
     * @param  bool           $buildSnapshots  Aggregate and persist JSON snapshots
     * @param  bool           $primeCache      Cache ‚Äúcache_only‚Äù indicators in Redis/file
     * @return array{inserted:int,snapshots:int,cache:int} Summary of operation counts
     */
    public function runForTicker(
        int $tickerId,
        array $indicatorNames = [],
        array $range = [],
        array $params = [],
        bool $writeCoreToDb = true,
        bool $buildSnapshots = false,
        bool $primeCache = false
    ): array {
        /*
        |--------------------------------------------------------------------------
        | 1. Ticker validation
        |--------------------------------------------------------------------------
        */
        $ticker = Ticker::find($tickerId);
        if (!$ticker) {
            Log::channel('ingest')->warning('‚ö†Ô∏è FeaturePipeline aborted: ticker not found', [
                'ticker_id' => $tickerId,
            ]);
            return ['inserted' => 0, 'snapshots' => 0, 'cache' => 0];
        }

        /*
        |--------------------------------------------------------------------------
        | 2. Load indicator configuration policy
        |--------------------------------------------------------------------------
        | This configuration drives the entire routing logic. Each section in
        | config/indicators.php defines where indicator results should be stored.
        */
        $storage   = config('indicators.storage');
        $defaults  = config('indicators.defaults');
        $cacheTtl  = (int) (config('indicators.cache_ttl.cache_only') ?? 86400);

        $coreSet     = $storage['ticker_indicators']        ?? ['macd','atr','adx','vwap'];
        $snapshotSet = $storage['ticker_feature_snapshots'] ?? [];
        $cacheSet    = $storage['cache_only']               ?? [];
        $onDemandSet = $storage['on_demand']                ?? [];

        /*
        |--------------------------------------------------------------------------
        | 3. Determine which indicators to compute
        |--------------------------------------------------------------------------
        | If no explicit list is passed, we compute the full union of all tiers.
        */
        if (empty($indicatorNames)) {
            $indicatorNames = array_values(array_unique(array_merge(
                $coreSet, $snapshotSet, $cacheSet, $onDemandSet
            )));
        }

        /*
        |--------------------------------------------------------------------------
        | 4. Parse indicator names (supporting suffix patterns)
        |--------------------------------------------------------------------------
        | Handles flexible module naming such as:
        |   "sma_50"      ‚Üí SMA with window=50
        |   "momentum_10" ‚Üí Momentum with window=10
        |   "ema_200"     ‚Üí EMA with window=200
        | Also normalizes `period` ‚áÑ `window` for cross-module compatibility.
        */
        $parsedIndicators = [];
        foreach ($indicatorNames as $name) {
            $name = trim($name);
            $paramsForThis = $params;

            if (preg_match('/^([a-zA-Z]+)_(\d{1,4})$/', $name, $m)) {
                $base   = strtolower($m[1]);
                $suffix = (int) $m[2];
                $paramsForThis[$base]['window'] = $suffix;
                $paramsForThis[$base]['period'] = $suffix; // normalized alias
                $parsedIndicators[] = [
                    'name'   => $base,
                    'params' => $paramsForThis[$base] ?? [],
                    'alias'  => $name,
                ];
            } else {
                $base = strtolower($name);
                $parsedIndicators[] = [
                    'name'   => $base,
                    'params' => $params[$base] ?? [],
                    'alias'  => $name,
                ];
            }
        }

        // Debug: show exactly what we intend to compute, and with what params.
        Log::channel('ingest')->info('üîé FeaturePipeline parsed indicators', [
            'parsed' => array_map(fn($p) => [
                'name'   => $p['name'],
                'alias'  => $p['alias'],
                'params' => $p['params'],
            ], $parsedIndicators),
        ]);

        /*
        |--------------------------------------------------------------------------
        | 5. Resolve active indicator modules
        |--------------------------------------------------------------------------
        | Registry::select dynamically maps module names ‚Üí instantiated classes.
        */
        $moduleNames = array_unique(array_map(fn($p) => $p['name'], $parsedIndicators));
        Log::channel('ingest')->info('üß© FeaturePipeline selecting modules', [
            'requested' => $moduleNames,
        ]);
        $modules = Registry::select($moduleNames);
        Log::channel('ingest')->info('‚úÖ Registry selected modules', [
            'count' => count($modules),
            'names' => array_map(fn($m) => $m->name, $modules),
        ]);

        if (empty($modules)) {
            Log::channel('ingest')->warning('‚ö†Ô∏è No valid indicator modules resolved', [
                'ticker' => $ticker->ticker,
            ]);
            return ['inserted' => 0, 'snapshots' => 0, 'cache' => 0];
        }

        /*
        |--------------------------------------------------------------------------
        | 6. Load OHLCV bars (daily resolution)
        |--------------------------------------------------------------------------
        */
        $q = TickerPriceHistory::query()
            ->where('ticker_id', $tickerId)
            ->where('resolution', '1d');

        if (!empty($range['from'])) $q->where('t', '>=', $range['from']);
        if (!empty($range['to']))   $q->where('t', '<=', $range['to']);

        $bars = $q->orderBy('t', 'asc')
            ->get(['t', 'o', 'h', 'l', 'c', 'v', 'vw'])
            ->map(fn($row) => [
                't'  => Carbon::parse($row->t)->toDateTimeString(),
                'o'  => (float) $row->o,
                'h'  => (float) $row->h,
                'l'  => (float) $row->l,
                'c'  => (float) $row->c,
                'v'  => (float) $row->v,
                'vw' => (float) $row->vw,
            ])
            ->values()
            ->all();

        if (empty($bars)) {
            Log::channel('ingest')->warning('‚ö†Ô∏è No OHLCV bars found for ticker', [
                'ticker' => $ticker->ticker,
                'range'  => $range,
            ]);
            return ['inserted' => 0, 'snapshots' => 0, 'cache' => 0];
        }

        Log::channel('ingest')->info('‚ñ∂Ô∏è FeaturePipeline start', [
            'ticker'  => $ticker->ticker,
            'modules' => array_map(fn($m) => $m->name, $modules),
            'range'   => $range,
            'bars'    => count($bars),
        ]);

        /*
        |--------------------------------------------------------------------------
        | 7. Compute indicators and route results
        |--------------------------------------------------------------------------
        | Each indicator module returns rows in the shape:
        |   ['t' => timestamp, 'indicator' => name, 'value' => float|null, 'meta' => mixed]
        */
        $dbRows         = [];
        $snapshotByDate = [];
        $cacheCount     = 0;

        foreach ($parsedIndicators as $pi) {
            $module = collect($modules)->firstWhere('name', $pi['name']);
            if (!$module) {
                Log::channel('ingest')->warning('‚ö†Ô∏è Indicator module missing (skipped)', ['name' => $pi['name']]);
                continue;
            }

            // Merge defaults with runtime params. Normalize period ‚Üî window.
            $modParams = array_replace_recursive($defaults[$pi['name']] ?? [], $pi['params'] ?? []);
            if (isset($modParams['period']) && !isset($modParams['window'])) {
                $modParams['window'] = $modParams['period'];
            }

            $rows = $module->compute($bars, $modParams);

            // üî¨ Post-compute probe: row count & first row sample (helps debug momentum_10)
            $firstSample = $rows[0] ?? null;
            Log::channel('ingest')->info('üßÆ Module computed', [
                'ticker' => $ticker->ticker,
                'module' => $pi['alias'] ?? $pi['name'],
                'rows'   => count($rows),
                'params' => $modParams,
                'sample' => $firstSample,
            ]);

            foreach ($rows as $r) {
                $t = isset($r['t']) ? Carbon::parse($r['t'])->toDateTimeString() : null;
                if (!$t) continue;

                // Snapshot Layer: collect configured indicators into per-day JSON
                if (in_array($pi['name'], $snapshotSet, true)) {
                    $day = substr($t, 0, 10);
                    $snapshotByDate[$day] = $snapshotByDate[$day] ?? [];
                    $snapshotByDate[$day][$r['indicator']] = [
                        'value' => $r['value'],
                        'meta'  => $r['meta'],
                    ];
                }

                // Core DB Layer: write only for explicitly configured core metrics
                if ($writeCoreToDb && in_array($pi['name'], $coreSet, true)) {
                    $dbRows[] = [
                        'ticker_id'  => $ticker->id,
                        'resolution' => '1d',
                        't'          => $t,
                        'indicator'  => $r['indicator'],
                        'value'      => $r['value'],
                        'meta'       => $r['meta'],
                        'created_at' => now()->toDateTimeString(),
                        'updated_at' => now()->toDateTimeString(),
                    ];
                }

                // Cache Layer: compact per-day blob for UI speed
                if ($primeCache && in_array($pi['name'], $cacheSet, true)) {
                    $cacheKey = "tw:ind:{$ticker->id}:{$pi['name']}:{$t}";
                    Cache::put($cacheKey, [
                        't'         => $t,
                        'indicator' => $r['indicator'],
                        'value'     => $r['value'],
                        'meta'      => $r['meta'],
                    ], $cacheTtl);
                    $cacheCount++;
                }
            }
        }

        /*
        |--------------------------------------------------------------------------
        | 8. Persist results
        |--------------------------------------------------------------------------
        | - ticker_indicators           ‚Üí upsert individual indicator records
        | - ticker_feature_snapshots   ‚Üí upsert aggregated JSON blobs
        */
        $inserted = 0;
        foreach (array_chunk($dbRows, 1000) as $chunk) {
            DB::table('ticker_indicators')->upsert(
                $chunk,
                ['ticker_id', 'resolution', 't', 'indicator'],
                ['value', 'meta', 'updated_at']
            );
            $inserted += count($chunk);
        }

        $snapshots = 0;
        if ($buildSnapshots && !empty($snapshotByDate)) {
            $payload = [];
            $now = now()->toDateTimeString();
            foreach ($snapshotByDate as $day => $kv) {
                $payload[] = [
                    'ticker_id'   => $ticker->id,
                    't'           => "{$day} 00:00:00",
                    'indicators'  => json_encode($kv, JSON_UNESCAPED_SLASHES),
                    'created_at'  => $now,
                    'updated_at'  => $now,
                ];
            }
            foreach (array_chunk($payload, 1000) as $chunk) {
                DB::table('ticker_feature_snapshots')->upsert(
                    $chunk,
                    ['ticker_id', 't'],
                    ['indicators', 'updated_at']
                );
                $snapshots += count($chunk);
            }
        }

        /*
        |--------------------------------------------------------------------------
        | 9. Final logging and return summary
        |--------------------------------------------------------------------------
        */
        Log::channel('ingest')->info('‚úÖ FeaturePipeline complete', [
            'ticker' => $ticker->ticker,
            'inserted_core_rows' => $inserted,
            'snapshots_upserted' => $snapshots,
            'cache_primed'       => $cacheCount,
        ]);

        return ['inserted' => $inserted, 'snapshots' => $snapshots, 'cache' => $cacheCount];
    }
}app/Services/BatchMonitorService.php


===== FILE: app/Services/BatchMonitorService.php =====

<?php

namespace App\Services;

use App\Models\JobBatch;
use Illuminate\Support\Facades\Log;
use Throwable;

/**
 * ============================================================================
 *  BatchMonitorService
 * ============================================================================
 *
 *  This service provides a thin abstraction layer around the `job_batches`
 *  table, which is managed by both:
 *      ‚Ä¢ Laravel's native Bus batching system (via Bus::batch)
 *      ‚Ä¢ TickerWolf's custom ingestion orchestration layer
 *
 *  It allows ingestion commands, cron jobs, and queued tasks to:
 *      - Create new batch records
 *      - Track incremental progress and completion
 *      - Record failures and pending counts
 *      - Keep a hybrid timestamp model:
 *          ‚Ä¢ `created_at`, `finished_at`, `cancelled_at` ‚Üí UNIX epoch (INT)
 *          ‚Ä¢ `updated_at` ‚Üí full DATETIME (timestamp)
 *
 *  This dual timestamp model ensures full compatibility with:
 *      ‚Ä¢ Laravel‚Äôs core `Illuminate\Bus\DatabaseBatchRepository`
 *      ‚Ä¢ Custom ORM-based progress tracking and log annotations
 * ============================================================================
 */
class BatchMonitorService
{
    /**
     * ------------------------------------------------------------------------
     *  Create a new batch record
     * ------------------------------------------------------------------------
     *  Creates an entry in the `job_batches` table to represent a new
     *  ingestion or compute batch. This ensures a unified view between
     *  Laravel's Bus repository and our custom ingestion monitor.
     *
     * @param  string  $name       Human-readable batch name (e.g. command name)
     * @param  int     $totalJobs  Total number of jobs in the batch
     * @return JobBatch|null
     */
    public static function createBatch(string $name, int $totalJobs): ?JobBatch
    {
        try {
            return JobBatch::create([
                'name'           => $name,
                'total_jobs'     => $totalJobs,
                'pending_jobs'   => $totalJobs,
                'failed_jobs'    => 0,
                'processed_jobs' => 0,
                'status'         => 'running',

                // ‚úÖ Use UNIX timestamps (INT) for Laravel Bus compatibility
                'created_at'     => now()->getTimestamp(),

                // ‚úÖ Keep updated_at as full DATETIME for Eloquent touch()
                'updated_at'     => now(),
            ]);
        } catch (Throwable $e) {
            Log::channel('ingest')->error("‚ùå Failed to create batch record", [
                'batch'  => $name,
                'error'  => $e->getMessage(),
            ]);
            return null;
        }
    }

    /**
     * ------------------------------------------------------------------------
     *  Increment progress as jobs complete successfully
     * ------------------------------------------------------------------------
     *  Increments the processed count, decrements pending jobs,
     *  and automatically marks the batch complete if all jobs finish.
     *
     * @param  string       $batchName  Batch name to update
     * @param  string|null  $ticker     Optional ticker symbol for context
     * @return void
     */
    public static function incrementProgress(string $batchName, ?string $ticker = null): void
    {
        try {
            $batch = JobBatch::where('name', $batchName)->latest('id')->first();

            if ($batch) {
                $batch->increment('processed_jobs');
                $batch->decrement('pending_jobs', min(1, $batch->pending_jobs));
                $batch->touch(); // updates updated_at (DATETIME)

                Log::channel('ingest')->info("üìà Batch progress incremented", [
                    'batch'          => $batchName,
                    'ticker'         => $ticker,
                    'processed_jobs' => $batch->processed_jobs,
                    'pending_jobs'   => $batch->pending_jobs,
                ]);

                // Auto-complete once all jobs are finished
                if ($batch->pending_jobs <= 0) {
                    $batch->update(['status' => 'complete']);
                    Log::channel('ingest')->info("‚úÖ Batch marked complete", [
                        'batch' => $batchName,
                    ]);
                }
            } else {
                Log::channel('ingest')->warning("‚ö†Ô∏è incrementProgress: No batch found", [
                    'batch' => $batchName,
                ]);
            }
        } catch (Throwable $e) {
            Log::channel('ingest')->error("‚ùå incrementProgress failed", [
                'batch' => $batchName,
                'error' => $e->getMessage(),
            ]);
        }
    }

    /**
     * ------------------------------------------------------------------------
     *  Decrement pending count (e.g., when a job finishes)
     * ------------------------------------------------------------------------
     *  Manually decrements the `pending_jobs` counter and increments
     *  `processed_jobs`, ensuring real-time batch progress visibility.
     *
     * @param  JobBatch  $jobBatch
     * @return void
     */
    public static function decrementPending(JobBatch $jobBatch): void
    {
        try {
            $jobBatch->decrement('pending_jobs');
            $jobBatch->increment('processed_jobs');
            $jobBatch->touch();
        } catch (Throwable $e) {
            Log::channel('ingest')->warning("‚ö†Ô∏è decrementPending failed", [
                'batch' => $jobBatch->name ?? 'unknown',
                'error' => $e->getMessage(),
            ]);
        }
    }

    /**
     * ------------------------------------------------------------------------
     *  Mark a batch job as failed
     * ------------------------------------------------------------------------
     *  Records a failed job within the batch, increments `failed_jobs`,
     *  decrements pending, and logs diagnostic details.
     *
     * @param  JobBatch  $jobBatch  The batch model instance
     * @param  string    $jobId     The job UUID or identifier
     * @return void
     */
    public static function markFailed(JobBatch $jobBatch, string $jobId): void
    {
        try {
            $jobBatch->increment('failed_jobs');
            $jobBatch->decrement('pending_jobs');
            $jobBatch->touch();

            Log::channel('ingest')->error("‚ùå Job failed in batch", [
                'batch' => $jobBatch->name,
                'job_id' => $jobId,
            ]);
        } catch (Throwable $e) {
            Log::channel('ingest')->warning("‚ö†Ô∏è markFailed failed", [
                'batch' => $jobBatch->name ?? 'unknown',
                'error' => $e->getMessage(),
            ]);
        }
    }
}app/Services/PolygonIndicatorsService.php


===== FILE: app/Services/PolygonIndicatorsService.php =====

<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;
use App\Models\Ticker;
use Throwable;
use Carbon\Carbon;
use Carbon\CarbonPeriod;

class PolygonIndicatorsService
{
    protected string $baseUrl;
    protected string $apiKey;
    protected int $timeout;
    protected int $maxRetries;
    protected string $logChannel;
    protected int $pageLimit;
    protected int $yearChunkSize; // years per request window

    public function __construct()
    {
        $this->baseUrl       = rtrim(config('services.polygon.base') ?? env('POLYGON_API_BASE', 'https://api.polygon.io'), '/');
        $this->apiKey        = (string) (config('services.polygon.key') ?? env('POLYGON_API_KEY'));
        $this->timeout       = (int) (env('POLYGON_API_TIMEOUT', 30));
        $this->maxRetries    = (int) (env('POLYGON_API_RETRIES', 3));
        $this->logChannel    = 'ingest';
        $this->pageLimit     = 5000;
        $this->yearChunkSize = .5; // request per .5-year slice
    }

    /**
     * Ingest multiple indicators for a single ticker across a date range.
     */
    public function fetchIndicators(string $ticker, array $indicators, array $range = []): void
    {
        $ticker = strtoupper(trim($ticker));
        $tickerModel = Ticker::where('ticker', $ticker)->first();

        if (! $tickerModel) {
            Log::channel($this->logChannel)->warning("‚ö†Ô∏è Indicators: unknown ticker, skipping", [
                'ticker' => $ticker,
            ]);
            return;
        }

        foreach ($indicators as $ind) {
            try {
                [$type, $period] = $this->parseIndicator($ind);
                Log::channel($this->logChannel)->info("‚ñ∂Ô∏è Fetching indicator", [
                    'ticker' => $ticker,
                    'indicator' => $ind,
                    'type' => $type,
                    'period' => $period,
                    'range' => $range,
                ]);

                $values = $this->fetchIndicatorDataChunked($ticker, $type, $period, $range);

                if (! empty($values)) {
                    $count = $this->storeIndicators($tickerModel->id, '1d', $ind, $values, $type);
                    Log::channel($this->logChannel)->info("‚úÖ Stored indicator data", [
                        'ticker' => $ticker,
                        'indicator' => $ind,
                        'records_inserted_or_updated' => $count,
                    ]);
                } else {
                    Log::channel($this->logChannel)->warning("‚ö†Ô∏è No indicator data returned", [
                        'ticker' => $ticker,
                        'indicator' => $ind,
                    ]);
                }
            } catch (Throwable $e) {
                Log::channel($this->logChannel)->error("‚ùå Indicator ingestion failed", [
                    'ticker' => $ticker,
                    'indicator' => $ind,
                    'message' => $e->getMessage(),
                    'trace' => substr($e->getTraceAsString(), 0, 1000),
                ]);
            }

            usleep(150_000); // pacing between API calls
        }
    }

    /** Parse "sma_20" ‚Üí ['sma', 20]; "macd" ‚Üí ['macd', null] */
    protected function parseIndicator(string $name): array
    {
        if (preg_match('/^(sma|ema|rsi)_(\d+)$/i', $name, $m)) {
            return [strtolower($m[1]), (int) $m[2]];
        }
        return [strtolower($name), null]; // e.g. macd
    }

    /**
     * Fetch an indicator from Polygon with date chunking (e.g., 1-year slices).
     */
    protected function fetchIndicatorDataChunked(string $ticker, string $type, ?int $window, array $range = []): array
    {
        $from = ! empty($range['from']) ? Carbon::parse($range['from']) : now()->subYears(10);
        $to   = ! empty($range['to'])   ? Carbon::parse($range['to'])   : now();
        $allValues = [];

        // build year-based chunks
        $periods = CarbonPeriod::create($from, "{$this->yearChunkSize} year", $to);
        $chunks = [];

        foreach ($periods as $p) {
            $start = $p->copy();
            $end   = $p->copy()->addYears($this->yearChunkSize)->subDay();
            if ($end->gt($to)) $end = $to;
            $chunks[] = ['from' => $start->toDateString(), 'to' => $end->toDateString()];
        }

        foreach ($chunks as $i => $chunk) {
            $values = $this->fetchIndicatorData($ticker, $type, $window, $chunk);

            Log::channel($this->logChannel)->info("üìÜ Chunk fetched", [
                'ticker' => $ticker,
                'indicator_type' => $type,
                'chunk_index' => $i + 1,
                'from' => $chunk['from'],
                'to' => $chunk['to'],
                'records' => count($values),
            ]);

            if (! empty($values)) {
                $allValues = array_merge($allValues, $values);
            }

            usleep(250_000); // small pause between chunks
        }

        return $allValues;
    }

    /**
     * Fetch indicator data for a single chunk.
     */
    protected function fetchIndicatorData(string $ticker, string $type, ?int $window, array $range = []): array
    {
        $endpoint = "/v1/indicators/{$type}/{$ticker}";
        $url = $this->baseUrl . $endpoint;

        $params = [
            'apiKey'      => $this->apiKey,
            'timespan'    => 'day',
            'series_type' => 'close',
            'limit'       => $this->pageLimit,
        ];

        if ($window) $params['window'] = $window;
        if (! empty($range['from'])) $params['from'] = $range['from'];
        if (! empty($range['to']))   $params['to']   = $range['to'];

        $attempt = 0;
        $wait = 2;

        while ($attempt < $this->maxRetries) {
            $attempt++;
            try {
                $resp = Http::timeout($this->timeout)->get($url, $params);

                if ($resp->successful()) {
                    $json = $resp->json();
                    return $json['results']['values'] ?? [];
                }

                if ($resp->status() === 429) {
                    $retryAfter = (int) ($resp->header('Retry-After') ?? $wait);
                    Log::channel($this->logChannel)->warning("‚ö†Ô∏è 429 rate limited", [
                        'ticker' => $ticker,
                        'indicator_type' => $type,
                        'retry_after' => $retryAfter,
                    ]);
                    sleep($retryAfter);
                    continue;
                }

                Log::channel($this->logChannel)->error("‚ùå HTTP failure", [
                    'ticker' => $ticker,
                    'indicator_type' => $type,
                    'status' => $resp->status(),
                    'body' => substr($resp->body(), 0, 300),
                ]);
                break;
            } catch (Throwable $e) {
                Log::channel($this->logChannel)->error("‚ùå Request exception", [
                    'ticker' => $ticker,
                    'indicator_type' => $type,
                    'message' => $e->getMessage(),
                ]);
                sleep($wait);
                $wait = min($wait * 2, 30);
            }
        }

        return [];
    }

    /**
     * Store indicator rows into ticker_indicators.
     */
    protected function storeIndicators(int $tickerId, string $resolution, string $indicator, array $values, string $type): int
    {
        $now = now()->toDateTimeString();
        $rows = [];

        foreach ($values as $v) {
            $ts = isset($v['timestamp'])
                ? now()->createFromTimestampMs((int) $v['timestamp'])->toDateTimeString()
                : null;

            if (! $ts) continue;

            $value = $v['value'] ?? null;
            $meta  = null;

            if ($type === 'macd') {
                $macd      = $v['macd']      ?? null;
                $signal    = $v['signal']    ?? null;
                $histogram = $v['histogram'] ?? null;

                $value = $macd;
                $meta  = json_encode(array_filter([
                    'signal' => $signal,
                    'histogram' => $histogram,
                ], fn($x) => $x !== null));
            }

            $rows[] = [
                'ticker_id'  => $tickerId,
                'resolution' => $resolution,
                't'          => $ts,
                'indicator'  => $indicator,
                'value'      => $value,
                'meta'       => $meta,
                'created_at' => $now,
                'updated_at' => $now,
            ];
        }

        if (empty($rows)) return 0;

        DB::table('ticker_indicators')->upsert(
            $rows,
            ['ticker_id', 'resolution', 't', 'indicator'],
            ['value', 'meta', 'updated_at']
        );

        return count($rows);
    }

    public function ingestMany(array $tickers, array $indicators, array $range = []): void
    {
        foreach ($tickers as $ticker) {
            $this->fetchIndicators($ticker, $indicators, $range);
        }
    }
}app/Services/PolygonTickerOverviewService.php


===== FILE: app/Services/PolygonTickerOverviewService.php =====

<?php

namespace App\Services;

use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Carbon;
use App\Models\Ticker;

class PolygonTickerOverviewService
{
    protected PolygonApiClient $client;
    protected array $tickerColumns;

    public function __construct(PolygonApiClient $client)
    {
        $this->client = $client;
        $this->tickerColumns = DB::getSchemaBuilder()->getColumnListing('tickers');
    }

    public function fetchAndUpsertOverview(Ticker $ticker): void
    {
        $endpoint = "/v3/reference/tickers/{$ticker->ticker}";
        $response = $this->client->get($endpoint);

        if (! $response->ok()) {
            $this->logFailure($ticker, "HTTP {$response->status()}");
            return;
        }

        $data = $response->json('results') ?? null;

        if (!$data) {
            $this->logFailure($ticker, 'No results returned');
            return;
        }

        $marketCap = is_numeric($data['market_cap'] ?? null) ? (int)$data['market_cap'] : null;

        DB::table('ticker_overviews')->upsert([[
            'ticker_id' => $ticker->id,
            'overview_date' => Carbon::now()->toDateString(),
            'active' => $data['active'] ?? null,
            'market_cap' => $marketCap,
            'primary_exchange' => $data['primary_exchange'] ?? null,
            'locale' => $data['locale'] ?? null,
            'status' => $data['status'] ?? 'unknown',
            'results_raw' => json_encode($data),
            'fetched_at' => now(),
            'updated_at' => now(),
        ]], ['ticker_id', 'overview_date'], [
            'active', 'market_cap', 'primary_exchange', 'locale',
            'status', 'results_raw', 'fetched_at', 'updated_at'
        ]);

        $updateData = array_intersect_key([
            'description' => $data['description'] ?? null,
            'homepage_url' => $data['homepage_url'] ?? null,
            'market_cap' => $marketCap,
            'total_employees' => $data['total_employees'] ?? null,
            'sic_code' => $data['sic_code'] ?? null,
            'branding_logo_url' => $data['branding']['logo_url'] ?? null,
            'branding_icon_url' => $data['branding']['icon_url'] ?? null,
        ], array_flip($this->tickerColumns));

        $ticker->fill($updateData);
        $ticker->save();
    }

    public function processBatch($tickers): void
    {
        foreach ($tickers as $ticker) {
            try {
                $this->fetchAndUpsertOverview($ticker);
            } catch (\Throwable $e) {
                $this->logFailure($ticker, $e->getMessage());
            }
        }
    }

    protected function logFailure(Ticker $ticker, string $reason): void
    {
        DB::table('failed_ticker_overviews')->insert([
            'ticker_id' => $ticker->id,
            'ticker' => $ticker->ticker,
            'reason' => $reason,
            'failed_at' => now(),
        ]);

        Log::warning("Failed overview for {$ticker->ticker}: {$reason}");
    }
}app/Services/PolygonFundamentalsService.php


===== FILE: app/Services/PolygonFundamentalsService.php =====

<?php

namespace App\Services;

use App\Models\Ticker;
use App\Models\TickerFundamental;
use App\Models\TickerFundamentalMetric;
use Illuminate\Support\Facades\Http;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Arr;
use Throwable;

class PolygonFundamentalsService
{
    protected string $baseUrl;
    protected string $apiKey;
    protected int $timeout;
    protected int $maxRetries;
    protected string $logChannel;

    public function __construct()
    {
        $this->baseUrl    = rtrim(config('services.polygon.base') ?? env('POLYGON_API_BASE', 'https://api.polygon.io'), '/');
        $this->apiKey     = (string) (config('services.polygon.key') ?? env('POLYGON_API_KEY'));
        $this->timeout    = (int) (env('POLYGON_API_TIMEOUT', 30));
        $this->maxRetries = (int) (env('POLYGON_API_RETRIES', 3));
        $this->logChannel = 'ingest'; // unified channel for all debug info
    }

    public function fetchAndStoreFundamentals(string $ticker, array $options = []): int
    {
        $symbol = strtoupper(trim($ticker));
        $tickerModel = Ticker::where('ticker', $symbol)->first();

        if (! $tickerModel) {
            Log::channel($this->logChannel)->warning("‚ö†Ô∏è Unknown ticker, skipping fundamentals ingestion", ['symbol' => $symbol]);
            return 0;
        }

        // üîß Respect Polygon's hard limit (max 100 per page)
        $limit = isset($options['limit']) && (int)$options['limit'] > 0 ? (int)$options['limit'] : 100;
        if ($limit > 100) $limit = 100;

        $params = [
            'ticker'    => $symbol,
            'limit'     => $limit,
            'order'     => in_array(strtolower($options['order'] ?? 'desc'), ['asc', 'desc'], true)
                ? strtolower($options['order'])
                : 'desc',
            'timeframe' => $options['timeframe'] ?? 'quarterly',
            'sort'      => $options['sort'] ?? 'filing_date',
        ];

        // ‚úÖ Add Polygon filing_date filters if provided via command options
        foreach (['filing_date.gte', 'filing_date.gt', 'filing_date.lte', 'filing_date.lt'] as $key) {
            if (!empty($options[$key])) {
                $params[$key] = $options[$key];
            }
        }

        $endpoint = '/vX/reference/financials';
        $nextUrl  = $this->buildUrl("{$this->baseUrl}{$endpoint}", $params);

        Log::channel($this->logChannel)->info("üåç Fetching fundamentals from Polygon", [
            'symbol' => $symbol,
            'url' => $nextUrl,
            'params' => $params,
        ]);

        $totalInserted = 0;
        $page = 0;

        while ($nextUrl) {
            $page++;
            $json = $this->safeGetJson($nextUrl);

            if (! $json) {
                Log::channel($this->logChannel)->warning("‚ö†Ô∏è Null or invalid JSON response", ['symbol' => $symbol, 'page' => $page]);
                break;
            }

            // Log snippet of the raw JSON for inspection
            Log::channel($this->logChannel)->debug("üßæ Raw JSON snippet", [
                'symbol' => $symbol,
                'page' => $page,
                'sample' => substr(json_encode(array_slice($json, 0, 5)), 0, 800),
            ]);

            $status  = $json['status'] ?? 'unknown';
            $results = $json['results'] ?? [];

            Log::channel($this->logChannel)->info("üìÑ Page summary", [
                'symbol' => $symbol,
                'page' => $page,
                'status' => $status,
                'results_count' => is_countable($results) ? count($results) : 0,
                'has_next_url' => isset($json['next_url']),
            ]);

            if (!is_array($results) || count($results) === 0) {
                Log::channel($this->logChannel)->warning("‚ö†Ô∏è No results returned for fundamentals", [
                    'symbol' => $symbol,
                    'status' => $status,
                    'json_keys' => array_keys($json ?? []),
                ]);
                break;
            }

            DB::beginTransaction();
            try {
                foreach ($results as $item) {
                    $topId = $this->upsertTopline($tickerModel, $symbol, $item);
                    if ($topId) {
                        $this->upsertMetrics($tickerModel, $symbol, $item, $topId);
                    }
                }
                DB::commit();
                $totalInserted += count($results);

                Log::channel($this->logChannel)->info("üíæ DB commit successful", [
                    'symbol' => $symbol,
                    'page' => $page,
                    'inserted_count' => count($results),
                ]);

            } catch (Throwable $e) {
                DB::rollBack();
                Log::channel($this->logChannel)->error("‚ùå DB transaction failed", [
                    'symbol' => $symbol,
                    'page' => $page,
                    'error' => $e->getMessage(),
                    'trace' => substr($e->getTraceAsString(), 0, 500),
                ]);
                break;
            }

            $nextUrl = $json['next_url'] ?? null;
            if ($nextUrl) {
                $nextUrl = $this->appendApiKey($nextUrl);
                usleep(250_000);
            }
        }

        Log::channel($this->logChannel)->info("‚úÖ Fundamentals ingestion complete", [
            'symbol' => $symbol,
            'total_inserted' => $totalInserted,
        ]);

        return $totalInserted;
    }

    protected function upsertTopline(Ticker $tickerModel, string $symbol, array $item): ?int
    {
        $unique = [
            'ticker_id'     => $tickerModel->id,
            'ticker'        => $symbol,
            'end_date'      => Arr::get($item, 'end_date'),
            'fiscal_period' => Arr::get($item, 'fiscal_period'),
            'fiscal_year'   => Arr::get($item, 'fiscal_year'),
        ];

        $balance  = Arr::get($item, 'financials.balance_sheet', []);
        $income   = Arr::get($item, 'financials.income_statement', []);
        $cashflow = Arr::get($item, 'financials.cash_flow_statement', []);

        $values = [
            'cik'                    => Arr::get($item, 'cik'),
            'company_name'           => Arr::get($item, 'company_name'),
            'timeframe'              => Arr::get($item, 'timeframe'),
            'status'                 => Arr::get($item, 'status'),
            'start_date'             => Arr::get($item, 'start_date'),
            'filing_date'            => Arr::get($item, 'filing_date'),
            'source_filing_url'      => Arr::get($item, 'source_filing_url'),
            'source_filing_file_url' => Arr::get($item, 'source_filing_file_url'),

            'total_assets'      => $this->num(Arr::get($balance, 'assets.value')),
            'total_liabilities' => $this->num(Arr::get($balance, 'liabilities.value')),
            'equity'            => $this->num(Arr::get($balance, 'equity.value')),
            'net_income'        => $this->num(Arr::get($income, 'net_income_loss.value')),
            'revenue'           => $this->num(Arr::get($income, 'revenues.value')),
            'operating_income'  => $this->num(Arr::get($income, 'operating_income_loss.value')),
            'gross_profit'      => $this->num(Arr::get($income, 'gross_profit.value')),
            'eps_basic'         => $this->num(Arr::get($income, 'basic_earnings_per_share.value'), 4),
            'eps_diluted'       => $this->num(Arr::get($income, 'diluted_earnings_per_share.value'), 4),

            'balance_sheet'        => $balance,
            'income_statement'     => $income,
            'cash_flow_statement'  => $cashflow,
            'comprehensive_income' => Arr::get($item, 'financials.comprehensive_income'),

            'raw'         => $item,
            'fetched_at'  => now(),
            'updated_at'  => now(),
            'created_at'  => now(),
        ];

        try {
            $existingId = TickerFundamental::query()->where($unique)->value('id');
            if ($existingId) {
                TickerFundamental::where('id', $existingId)->update($values);
                return (int)$existingId;
            }

            $record = TickerFundamental::create(array_merge($unique, $values));
            return $record->id ?? null;
        } catch (Throwable $e) {
            Log::channel($this->logChannel)->error("‚ùå Failed to upsert topline", [
                'symbol' => $symbol,
                'error' => $e->getMessage(),
                'trace' => substr($e->getTraceAsString(), 0, 500),
            ]);
            return null;
        }
    }

    protected function upsertMetrics(Ticker $tickerModel, string $symbol, array $item, ?int $topId): int
    {
        $financials = Arr::get($item, 'financials', []);
        if (empty($financials)) return 0;

        $endDate = Arr::get($item, 'end_date');
        $period  = Arr::get($item, 'fiscal_period');
        $year    = Arr::get($item, 'fiscal_year');
        $rows = [];
        $now = now()->toDateTimeString();

        foreach (['balance_sheet','income_statement','cash_flow_statement','comprehensive_income'] as $statement) {
            $section = Arr::get($financials, $statement, []);
            foreach ($section as $key => $node) {
                if (!is_array($node)) continue;
                $value = Arr::get($node, 'value');
                if (!is_numeric($value) && $value !== 0) continue;

                $rows[] = [
                    'ticker_id'      => $tickerModel->id,
                    'ticker'         => $symbol,
                    'fundamental_id' => $topId,
                    'statement'      => $statement,
                    'line_item'      => $key,
                    'label'          => Arr::get($node, 'label'),
                    'unit'           => Arr::get($node, 'unit'),
                    'display_order'  => Arr::get($node, 'order'),
                    'value'          => $this->num($value),
                    'end_date'       => $endDate,
                    'fiscal_period'  => $period,
                    'fiscal_year'    => $year,
                    'created_at'     => $now,
                    'updated_at'     => $now,
                ];
            }
        }

        if (empty($rows)) return 0;

        try {
            TickerFundamentalMetric::upsert(
                $rows,
                ['ticker_id', 'end_date', 'statement', 'line_item'],
                ['label','unit','display_order','value','fiscal_period','fiscal_year','updated_at']
            );

            Log::channel($this->logChannel)->debug("üìà Inserted fundamental metrics", [
                'symbol' => $symbol,
                'count' => count($rows),
            ]);

            return count($rows);
        } catch (Throwable $e) {
            Log::channel($this->logChannel)->error("‚ùå Failed to upsert metrics", [
                'symbol' => $symbol,
                'error' => $e->getMessage(),
                'trace' => substr($e->getTraceAsString(), 0, 500),
            ]);
            return 0;
        }
    }

    protected function safeGetJson(string $url): ?array
    {
        $attempt = 0;
        $wait = 2;

        while ($attempt < $this->maxRetries) {
            $attempt++;
            try {
                $resp = Http::timeout($this->timeout)->get($url);

                if ($resp->successful()) {
                    $data = $resp->json();
                    Log::channel($this->logChannel)->debug("‚úÖ HTTP success", [
                        'url' => $url,
                        'attempt' => $attempt,
                        'status' => $resp->status(),
                    ]);
                    return (array) $data;
                }

                Log::channel($this->logChannel)->error("‚ùå Polygon HTTP error", [
                    'url' => $url,
                    'status' => $resp->status(),
                    'body_snippet' => substr($resp->body(), 0, 500),
                ]);

                if ($resp->status() === 429) {
                    $retryAfter = (int)($resp->header('Retry-After') ?? $wait);
                    Log::channel($this->logChannel)->warning("Rate limited, retrying...", [
                        'retry_after' => $retryAfter,
                    ]);
                    sleep($retryAfter);
                    continue;
                }

                return null;
            } catch (Throwable $e) {
                Log::channel($this->logChannel)->error("HTTP exception", [
                    'url' => $url,
                    'error' => $e->getMessage(),
                ]);
                sleep($wait);
                $wait *= 2;
            }
        }

        return null;
    }

    // ‚úÖ FIXED: Prevent encoding dots in query keys like "filing_date.gte"
    protected function buildUrl(string $base, array $params): string
    {
        $params['apiKey'] = $this->apiKey;

        // Build the query string manually to avoid encoding dots in keys
        $query = collect($params)->map(function ($v, $k) {
            return $k . '=' . urlencode((string) $v);
        })->implode('&');

        return $base . (str_contains($base, '?') ? '&' : '?') . $query;
    }

    protected function appendApiKey(string $url): string
    {
        return str_contains($url, 'apiKey=') ? $url : $url . (str_contains($url, '?') ? '&' : '?') . 'apiKey=' . urlencode($this->apiKey);
    }

    protected function num($v, int $scale = 2): ?float
    {
        if ($v === null || $v === '' || (!is_numeric($v) && $v !== 0 && $v !== '0')) {
            return null;
        }
        return round((float)$v, $scale);
    }
}app/Services/PolygonTickerNewsService.php


===== FILE: app/Services/PolygonTickerNewsService.php =====

<?php

namespace App\Services;

use App\Models\Ticker;
use App\Models\TickerNewsItem;
use Illuminate\Support\Facades\Http;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Arr;

class PolygonTickerNewsService
{
    protected string $apiKey;
    protected string $baseUrl;

    public function __construct()
    {
        $this->apiKey  = (string) config('services.polygon.key');
        $this->baseUrl = 'https://api.polygon.io/v2/reference/news';
    }

    /**
     * Fetch and store news for a single ticker.
     */
    public function fetchNewsForTicker(string $ticker, int $limit = 50): int
    {
        $symbol = strtoupper(trim($ticker));
        $url    = "{$this->baseUrl}?ticker={$symbol}&limit={$limit}&apiKey={$this->apiKey}";
        $resp   = Http::timeout(30)->get($url);

        if (! $resp->ok()) {
            Log::channel('ingest')->error("Polygon News API failed for {$symbol}", [
                'status' => $resp->status(),
                'body'   => $resp->body(),
            ]);
            return 0;
        }

        $json    = $resp->json() ?? [];
        $results = $json['results'] ?? [];

        if (!is_array($results) || empty($results)) {
            return 0;
        }

        $count = 0;
        foreach ($results as $item) {
            $count += $this->storeNewsItem($symbol, (array) $item);
        }

        Log::channel('ingest')->info("üì∞ Ingested {$count} news items for {$symbol}");
        return $count;
    }

    /**
     * Store a single Polygon.io news item.
     */
    protected function storeNewsItem(string $symbol, array $item): int
    {
        try {
            $tickerModel = Ticker::where('ticker', $symbol)->first();

            // Flatten one insight if present
            $insight = is_array($item['insights'] ?? null) && count($item['insights']) > 0
                ? (array) $item['insights'][0]
                : null;

            // Build a deterministic unique article_id per ticker
            $articleId = $item['id'] ?? null;
            $hashSource = ($symbol ?? '') . '|' .
                          ($item['article_url'] ?? '') . '|' .
                          ($item['published_utc'] ?? '') . '|' .
                          ($item['title'] ?? '') . '|' .
                          ($item['author'] ?? '');
            $articleId = $articleId ? "{$symbol}_{$articleId}" : md5($hashSource);

            $attributes = [
                'article_id' => $articleId,
            ];

            $values = [
                'ticker_id'              => $tickerModel?->id,
                'ticker'                 => $symbol,

                // Author / Publisher
                'author'                 => $item['author'] ?? null,
                'publisher_name'         => Arr::get($item, 'publisher.name'),
                'publisher_logo_url'     => Arr::get($item, 'publisher.logo_url'),
                'publisher_favicon_url'  => Arr::get($item, 'publisher.favicon_url'),
                'publisher_homepage_url' => Arr::get($item, 'publisher.homepage_url'),

                // Core content
                'title'                  => $item['title'] ?? null,
                'summary'                => $item['description'] ?? null,
                'url'                    => $item['article_url'] ?? null,
                'amp_url'                => $item['amp_url'] ?? null,
                'image_url'              => $item['image_url'] ?? null,

                // Arrays (cast to array in model)
                'tickers_list'           => isset($item['tickers'])  ? array_values((array) $item['tickers'])  : null,
                'keywords'               => isset($item['keywords']) ? array_values((array) $item['keywords']) : null,
                'insights'               => isset($item['insights']) ? (array) $item['insights']               : null,

                // Flattened insight fields
                'insight_sentiment'      => $insight['sentiment'] ?? null,
                'insight_reasoning'      => $insight['sentiment_reasoning'] ?? null,
                'insight_ticker'         => $insight['ticker'] ?? null,

                // Publish time
                'published_utc'          => isset($item['published_utc'])
                    ? date('Y-m-d H:i:s', strtotime($item['published_utc']))
                    : null,

                // Store raw payload
                'raw'                    => $item,
                'updated_at'             => now(),
                'created_at'             => now(),
            ];

            TickerNewsItem::updateOrCreate($attributes, $values);

            return 1;
        } catch (\Throwable $e) {
            Log::channel('ingest')->error("‚ùå Failed to store news for {$symbol}: {$e->getMessage()}", [
                'item' => $item,
            ]);
            return 0;
        }
    }

    /**
     * Ingest for all active tickers (simple sequential mode).
     */
    public function ingestAllTickers(int $limit = 50): void
    {
        Ticker::where('active', true)
            ->orderBy('id')
            ->pluck('ticker')
            ->each(function ($sym) use ($limit) {
                $this->fetchNewsForTicker($sym, $limit);
                usleep(400_000); // 0.4s pacing
            });
    }
}app/Services/PolygonTickerService.php


===== FILE: app/Services/PolygonTickerService.php =====

<?php

namespace App\Services;

use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Carbon;
use Throwable;

/**
 * Handles ingestion of all tickers from the Polygon.io API.
 * Supports automatic pagination, rate limit backoff, and resumable polling.
 */
class PolygonTickerService
{
    protected PolygonApiClient $client;

    // Default polling interval (seconds)
    protected int $pollInterval = 10;

    public function __construct(PolygonApiClient $client)
    {
        $this->client = $client;
    }

    /**
     * Ingest all tickers via Polygon reference endpoint.
     *
     * @param  array  $options  Additional query params (e.g. ['market' => 'stocks'])
     * @param  bool   $poll     Whether to continuously poll for updates
     */
    public function ingestAll(array $options = [], bool $poll = false): array
    {
        do {
            $stats = $this->runIngestionPass($options);

            Log::info('Polygon ticker ingestion completed', [
                'pages' => $stats['pages'],
                'inserted' => $stats['inserted'],
                'timestamp' => now()->toDateTimeString(),
            ]);

            if ($poll) {
                Log::info("Sleeping {$this->pollInterval}s before next polling pass...");
                sleep($this->pollInterval);
            }

        } while ($poll);

        return $stats;
    }

    /**
     * Executes a single ingestion run (all pages).
     */
    protected function runIngestionPass(array $options = []): array
    {
        $endpoint = '/v3/reference/tickers';
        $params = array_merge(['limit' => 1000], $options);

        $nextUrl = $endpoint . '?' . http_build_query($params);
        $pages = 0;
        $totalInserted = 0;

        while ($nextUrl) {
            $pages++;
            try {
                $response = $this->client->get($nextUrl);

                if (! $response->ok()) {
                    Log::error('Polygon ticker ingestion failed', [
                        'url' => $nextUrl,
                        'status' => $response->status(),
                        'body' => $response->body(),
                    ]);
                    break;
                }

                $json = $response->json();
                $results = $json['results'] ?? [];

                if (!empty($results)) {
                    [$inserted] = $this->persistTickerResults($results);
                    $totalInserted += $inserted;
                }

                // Determine next page
                $nextUrl = $json['next_url'] ?? null;
                if ($nextUrl) {
                    $nextUrl = $this->appendApiKey($nextUrl);
                    sleep(1); // gentle pause between pages
                }

            } catch (Throwable $e) {
                Log::error('Polygon ticker ingestion exception', [
                    'url' => $nextUrl,
                    'message' => $e->getMessage(),
                ]);

                // Retry logic for transient issues (MySQL disconnects, network hiccups, etc.)
                sleep(5);
                continue;
            }

            // Basic rate limit pacing (Polygon's free tier = ~5 req/s)
            sleep(2);
        }

        return [
            'inserted' => $totalInserted,
            'pages' => $pages,
        ];
    }

    /**
     * Append the Polygon API key to a URL if missing.
     */
    protected function appendApiKey(string $url): string
    {
        return str_contains($url, 'apiKey=')
            ? $url
            : $url . (str_contains($url, '?') ? '&' : '?') . 'apiKey=' . urlencode(env('POLYGON_API_KEY'));
    }

    /**
     * Upsert ticker rows into the database.
     */
    protected function persistTickerResults(array $results): array
    {
        $now = now()->toDateTimeString();
        $rows = [];

        foreach ($results as $item) {
            $rows[] = [
                'ticker' => $item['ticker'] ?? null,
                'name' => $item['name'] ?? null,
                'market' => $item['market'] ?? null,
                'locale' => $item['locale'] ?? null,
                'primary_exchange' => $item['primary_exchange'] ?? null,
                'type' => $item['type'] ?? null,
                'status' => $item['status'] ?? null,
                'active' => $item['active'] ?? null,
                'currency_symbol' => $item['currency_symbol'] ?? null,
                'currency_name' => $item['currency_name'] ?? null,
                'composite_figi' => $item['composite_figi'] ?? null,
                'share_class_figi' => $item['share_class_figi'] ?? null,
                'last_updated_utc' => isset($item['last_updated_utc'])
                    ? Carbon::parse($item['last_updated_utc'])->toDateTimeString()
                    : null,
                'delisted_utc' => isset($item['delisted_utc'])
                    ? Carbon::parse($item['delisted_utc'])->toDateTimeString()
                    : null,
                'raw' => json_encode($item),
                'created_at' => $now,
                'updated_at' => $now,
            ];
        }

        if (!empty($rows)) {
            DB::table('tickers')->upsert(
                $rows,
                ['ticker'],
                [
                    'name', 'market', 'locale', 'primary_exchange',
                    'type', 'status', 'active', 'currency_symbol',
                    'currency_name', 'composite_figi', 'share_class_figi',
                    'last_updated_utc', 'delisted_utc', 'raw', 'updated_at',
                ]
            );
        }

        return [count($rows)];
    }
}app/Services/Validation/Probes/PolygonProbe.php


===== FILE: app/Services/Validation/Probes/PolygonProbe.php =====

<?php

namespace App\Services\Validation\Probes;

use App\Services\PolygonApiClient;
use Illuminate\Support\Facades\Log;

/**
 * ============================================================================
 *  PolygonProbe
 * ============================================================================
 *
 * üîß Purpose:
 *   Lightweight utility that checks whether Polygon.io
 *   currently has any valid upstream data for a given ticker.
 *
 * üß† Behavior:
 * ----------------------------------------------------------------------------
 *   ‚Ä¢ Calls PolygonApiClient (aggregate or reference endpoint)
 *   ‚Ä¢ Distinguishes "no data" vs "upstream error"
 *   ‚Ä¢ Returns structured probe results used by validators
 *
 * üì¶ Typical Response:
 *   [
 *     'status'   => 200,
 *     'latency'  => 83,
 *     'found'    => true,
 *     'message'  => 'OK',
 *     'raw_size' => 4201
 *   ]
 * ============================================================================
 */
class PolygonProbe
{
    public function __construct(protected PolygonApiClient $client) {}

    /**
     * Test whether Polygon.io has recent data for a ticker.
     *
     * @param  string  $symbol
     * @return array<string,mixed>
     */
    public function checkTickerData(string $symbol): array
    {
        $start = microtime(true);

        try {
            // Query the most recent daily aggregate (lightweight)
            $response = $this->client->get("/v2/aggs/ticker/{$symbol}/prev");
            $elapsed  = round((microtime(true) - $start) * 1000, 2);

            if (empty($response) || !isset($response['results']) || count($response['results']) === 0) {
                return [
                    'status'  => $response['status'] ?? 200,
                    'latency' => $elapsed,
                    'found'   => false,
                    'message' => 'Upstream empty response',
                    'raw_size'=> 0,
                ];
            }

            return [
                'status'   => 200,
                'latency'  => $elapsed,
                'found'    => true,
                'message'  => 'OK',
                'raw_size' => strlen(json_encode($response)),
            ];
        } catch (\Throwable $e) {
            $elapsed = round((microtime(true) - $start) * 1000, 2);
            Log::channel('ingest')->warning('‚ö†Ô∏è Polygon probe failed', [
                'symbol'  => $symbol,
                'message' => $e->getMessage(),
            ]);

            return [
                'status'  => 500,
                'latency' => $elapsed,
                'found'   => false,
                'message' => $e->getMessage(),
                'raw_size'=> 0,
            ];
        }
    }
}app/Services/Validation/DataIntegrityService.php


===== FILE: app/Services/Validation/DataIntegrityService.php =====

<?php

namespace App\Services\Validation;

use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Config;
use App\Services\Validation\Validators\PolygonDataValidator;

/**
 * ============================================================================
 *  DataIntegrityService  (v2 ‚Äî Config-Driven + Severity Scoring)
 * ============================================================================
 *
 * üîß Purpose:
 *   Performs configurable structural validation of ticker price histories
 *   (duplicates, gaps, flatlines, spikes) and coordinates with
 *   PolygonDataValidator to confirm upstream data availability.
 *
 * üß† Behavior:
 * ----------------------------------------------------------------------------
 *   ‚Ä¢ Loads configurable thresholds and weights from config/data_validation.php.
 *   ‚Ä¢ Detects anomalies and computes severity scores (0‚Äì1).
 *   ‚Ä¢ Aggregates an overall ticker ‚Äúhealth score‚Äù (1 = perfect, 0 = bad).
 *   ‚Ä¢ Delegates missing or empty datasets to PolygonDataValidator.
 *   ‚Ä¢ Returns unified structured results for commands/loggers.
 *
 * üì¶ Example Output:
 *   [
 *     'ticker_id'   => 8255,
 *     'health'      => 0.93,
 *     'severity'    => ['gaps'=>0.02,'flat'=>0.03,'spikes'=>0.01],
 *     'issues'      => ['gaps'=>[...],'flat'=>[...]],
 *     'root_causes' => ['missing_price_data'=>'upstream_empty_response'],
 *     'upstream'    => ['status'=>200,'found'=>false],
 *   ]
 * ============================================================================
 */
class DataIntegrityService
{
    public function __construct(
        protected ?PolygonDataValidator $polygonValidator = null
    ) {
        $this->polygonValidator = $this->polygonValidator ?? app(PolygonDataValidator::class);
    }

    /**
     * Scan ticker data for local anomalies + upstream validation.
     *
     * @param  int  $tickerId
     * @return array<string,mixed>
     */
    public function scanTicker(int $tickerId): array
    {
        /*
        |--------------------------------------------------------------------------
        | 1Ô∏è‚É£ Load bars
        |--------------------------------------------------------------------------
        */
        $bars = DB::table('ticker_price_histories')
            ->where('ticker_id', $tickerId)
            ->where('resolution', '1d')
            ->orderBy('t', 'asc')
            ->get(['t', 'c'])
            ->map(fn($r) => ['t' => $r->t, 'c' => (float) $r->c])
            ->toArray();

        $cfg = Config::get('data_validation', [
            'gap_days_tolerance'    => 10,
            'flat_streak_tolerance' => 5,
            'spike_threshold'       => 0.5,
            'weights'               => ['gaps'=>0.4,'flat'=>0.3,'spikes'=>0.3],
            'min_bars'              => 10,
        ]);

        $result = [
            'ticker_id'   => $tickerId,
            'issues'      => [],
            'root_causes' => [],
            'upstream'    => null,
            'health'      => 1.0,
            'severity'    => [],
        ];

        /*
        |--------------------------------------------------------------------------
        | 2Ô∏è‚É£ Handle insufficient local data
        |--------------------------------------------------------------------------
        */
        if (count($bars) < $cfg['min_bars']) {
            Log::channel('ingest')->warning('‚ö†Ô∏è Insufficient local bars', ['ticker_id' => $tickerId]);

            $symbol = DB::table('tickers')->where('id', $tickerId)->value('ticker');
            if ($symbol) {
                $validation = $this->polygonValidator->validateTicker($tickerId, $symbol);
                $result = array_merge($result, $validation);
            }

            $result['status'] = 'insufficient';
            $result['health'] = 0.0;
            return $result;
        }

        /*
        |--------------------------------------------------------------------------
        | 3Ô∏è‚É£ Local anomaly detection
        |--------------------------------------------------------------------------
        */
        $issues = ['duplicates'=>[], 'gaps'=>[], 'flat'=>[], 'spikes'=>[]];
        $dates  = array_column($bars, 't');
        $closes = array_column($bars, 'c');
        $total  = count($closes);

        // Duplicates
        $dupes = collect($bars)->groupBy('t')->filter(fn($g) => $g->count() > 1)->keys()->all();
        if ($dupes) $issues['duplicates'] = $dupes;

        // Gaps
        for ($i = 1; $i < $total; $i++) {
            $diff = (strtotime($dates[$i]) - strtotime($dates[$i - 1])) / 86400;
            if ($diff > $cfg['gap_days_tolerance']) {
                $issues['gaps'][] = ['from'=>$dates[$i - 1],'to'=>$dates[$i],'days'=>$diff];
            }
        }

        // Flatlines + Spikes
        for ($i = 1; $i < $total; $i++) {
            $prev = $closes[$i - 1];
            $curr = $closes[$i];
            $ret  = $prev > 0 ? ($curr - $prev) / $prev : 0.0;

            if ($curr == $prev) {
                $issues['flat'][] = $dates[$i];
            } elseif (abs($ret) > $cfg['spike_threshold']) {
                $issues['spikes'][] = ['date'=>$dates[$i],'return'=>round($ret,2)];
            }
        }

        /*
        |--------------------------------------------------------------------------
        | 4Ô∏è‚É£ Severity scoring & health aggregation
        |--------------------------------------------------------------------------
        */
        $weights  = $cfg['weights'];
        $severity = [];

        foreach (['gaps','flat','spikes'] as $key) {
            $count = count($issues[$key]);
            $severity[$key] = min(1.0, $count / max(1, $total)) * ($weights[$key] ?? 0);
        }

        $totalSeverity = array_sum($severity);
        $health = max(0.0, round(1 - $totalSeverity, 4));

        $result['issues']   = array_filter($issues, fn($v)=>!empty($v));
        $result['severity'] = $severity;
        $result['health']   = $health;
        $result['status']   = $health < 0.9 ? 'warning' : 'success';

        /*
        |--------------------------------------------------------------------------
        | 5Ô∏è‚É£ Integrate Polygon upstream verification if data missing entirely
        |--------------------------------------------------------------------------
        */
        if (empty($bars)) {
            $symbol = DB::table('tickers')->where('id', $tickerId)->value('ticker');
            if ($symbol) {
                $validation = $this->polygonValidator->validateTicker($tickerId, $symbol);
                $result = array_merge($result, $validation);
            }
        }

        /*
        |--------------------------------------------------------------------------
        | 6Ô∏è‚É£ Logging + Return
        |--------------------------------------------------------------------------
        */
        if ($health < 0.9) {
            Log::channel('ingest')->warning('‚ö†Ô∏è Data integrity warning', [
                'ticker_id' => $tickerId,
                'health'    => $health,
                'severity'  => $severity,
                'issues'    => array_keys($result['issues']),
            ]);
        }

        return $result;
    }
}app/Services/Validation/Validators/PolygonDataValidator.php


===== FILE: app/Services/Validation/Validators/PolygonDataValidator.php =====

<?php

namespace App\Services\Validation\Validators;

use App\Services\Validation\Probes\PolygonProbe;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Http;
use Illuminate\Support\Facades\Log;

/**
 * ============================================================================
 *  PolygonDataValidator (v2.2 ‚Äî adds live verifyTickerUpstream)
 * ============================================================================
 *
 * üîß Purpose:
 *   Bridges local Polygon.io‚Äìsourced data validation with live upstream
 *   verification. Performs both local completeness checks and on-the-fly
 *   Polygon API probes.
 *
 * üß† Behavior:
 * ----------------------------------------------------------------------------
 *   ‚Ä¢ validateTicker() ‚Üí existing local+upstream completeness logic.
 *   ‚Ä¢ verifyTickerUpstream() ‚Üí NEW: direct live API check for recent bars.
 * ============================================================================
 *   This validator acts as the ‚Äúbridge‚Äù between **local data health** and
 *   **Polygon upstream truth**. It performs a two-phase analysis:
 *
 *   1Ô∏è‚É£ **Local Completeness Check**
 *       - Confirms the ticker has sufficient rows in `ticker_price_histories`
 *         for the expected date range (e.g. several hundred trading days).
 *       - Flags any tickers with *zero* records or extremely small counts
 *         (`< 5` bars total) as ‚Äúmissing_price_data‚Äù.
 *       - Optionally could later expand to detect *partial ranges* (e.g.,
 *         a symbol with data only from 2024 but missing 2023).
 *
 *   2Ô∏è‚É£ **Upstream Root-Cause Probe**
 *       - When local data is missing or empty, the validator calls
 *         `PolygonProbe::checkTickerData()` to determine whether Polygon.io
 *         also reports no data.
 *       - This distinguishes:
 *           üü¢ Upstream Empty (Polygon has no data) ‚Üí ‚Äúupstream_empty_response‚Äù
 *           üü† Local Failure  (Polygon has data, but we failed to ingest it)
 *           üî¥ Upstream Error (Polygon API returned 4xx/5xx or rate-limit)
 *
 *   3Ô∏è‚É£ **Gap and Coverage Analysis**
 *       - The validator can be extended to check for time gaps between
 *         local bars (e.g. ‚â•5 consecutive missing weekdays) to identify
 *         *partial data availability* cases.
 *       - These ‚Äúcoverage anomalies‚Äù will be surfaced as
 *         `'partial_price_history' => ['missing_days' => N]` in results.
 *
 * üßÆ Decision Logic:
 * ----------------------------------------------------------------------------
 *   ‚Ä¢ If 0 bars locally ‚Üí mark `missing_price_data` and call PolygonProbe.
 *   ‚Ä¢ If 1‚Äì4 bars ‚Üí mark as ‚Äúinsufficient sample‚Äù.
 *   ‚Ä¢ If Polygon returns HTTP 200 but empty ‚Üí `upstream_empty_response`.
 *   ‚Ä¢ If Polygon returns non-200 ‚Üí `upstream_error`.
 *   ‚Ä¢ If Polygon returns valid bars but none locally ‚Üí `local_ingestion_failure`.
 *
 * üì¶ Example Result:
 * ----------------------------------------------------------------------------
 *   [
 *     'issues'       => ['missing_price_data'],
 *     'root_causes'  => ['missing_price_data' => 'upstream_empty_response'],
 *     'upstream'     => ['status' => 200, 'found' => false],
 *     'valid'        => false,
 *   ]
 *
 * ============================================================================
 */
class PolygonDataValidator
{
    public function __construct(protected PolygonProbe $probe) {}

    /**
     * Validate Polygon-sourced data for one ticker (local + probe).
     */
    public function validateTicker(int $tickerId, string $symbol): array
    {
        $result = [
            'issues'      => [],
            'root_causes' => [],
            'upstream'    => null,
            'valid'       => true,
        ];

        // 1Ô∏è‚É£ Local completeness check
        $count = DB::table('ticker_price_histories')
            ->where('ticker_id', $tickerId)
            ->count();

        if ($count === 0) {
            $result['issues'][] = 'missing_price_data';
            $result['valid']    = false;

            // 2Ô∏è‚É£ Probe Polygon upstream (cached probe class)
            $probeResult = $this->probe->checkTickerData($symbol);
            $result['upstream'] = $probeResult;

            if ($probeResult['found'] === false) {
                $result['root_causes']['missing_price_data'] = 'upstream_empty_response';
            } elseif ($probeResult['status'] !== 200) {
                $result['root_causes']['missing_price_data'] = 'upstream_error';
            } else {
                $result['root_causes']['missing_price_data'] = 'local_ingestion_failure';
            }
        } elseif ($count < 5) {
            $result['issues'][] = 'insufficient_price_data';
            $result['valid']    = false;
        }

        return $result;
    }

    /**
     * üîç Live Polygon.io verification for a ticker (read-only).
     *
     * @param  string  $symbol
     * @param  int     $daysBack  Defaults to 30
     * @return array<string,mixed>
     */
    public function verifyTickerUpstream(string $symbol, int $daysBack = 30): array
    {
        $apiKey = config('services.polygon.key');
        $now  = now()->format('Y-m-d');
        $past = now()->subDays($daysBack)->format('Y-m-d');
        $url  = "https://api.polygon.io/v2/aggs/ticker/{$symbol}/range/1/day/{$past}/{$now}";

        try {
            $resp = Http::timeout(8)->get($url, ['apiKey' => $apiKey, 'limit' => 5]);
            $status = $resp->status();

            if ($status === 429) {
                Log::warning("‚ö†Ô∏è Polygon rate-limit hit during verifyTickerUpstream", ['symbol' => $symbol]);
                return [
                    'symbol'     => $symbol,
                    'status'     => 429,
                    'found'      => false,
                    'count'      => 0,
                    'message'    => 'rate_limited',
                    'checked_at' => now()->toIso8601String(),
                ];
            }

            if (!$resp->ok()) {
                return [
                    'symbol'     => $symbol,
                    'status'     => $status,
                    'found'      => false,
                    'count'      => 0,
                    'message'    => "HTTP {$status}",
                    'checked_at' => now()->toIso8601String(),
                ];
            }

            $json  = $resp->json();
            $count = $json['resultsCount'] ?? 0;
            $found = $count > 0;

            return [
                'symbol'     => $symbol,
                'status'     => $status,
                'found'      => $found,
                'count'      => $count,
                'message'    => $found ? 'ok' : 'empty',
                'checked_at' => now()->toIso8601String(),
            ];
        } catch (\Throwable $e) {
            Log::error("‚ùå verifyTickerUpstream failed", [
                'symbol' => $symbol,
                'error'  => $e->getMessage(),
            ]);
            return [
                'symbol'     => $symbol,
                'status'     => 0,
                'found'      => false,
                'count'      => 0,
                'message'    => $e->getMessage(),
                'checked_at' => now()->toIso8601String(),
            ];
        }
    }
}app/Services/Analytics/BaseAnalytics.php


===== FILE: app/Services/Analytics/BaseAnalytics.php =====

<?php

namespace App\Services\Analytics;

use App\Services\Compute\BaseIndicator;

/**
 * BaseAnalytics
 *
 * Provides access to BaseIndicator math utilities (returns, variance, etc.)
 * without requiring `compute()` to be implemented.
 */
abstract class BaseAnalytics extends BaseIndicator
{
    public function compute(array $bars, array $params = []): array
    {
        // No-op, since analytics services use custom entry points.
        return [];
    }
}
app/Services/Analytics/FeatureSnapshotBuilder.php


===== FILE: app/Services/Analytics/FeatureSnapshotBuilder.php =====

<?php

namespace App\Services\Analytics;

use App\Models\Ticker;
use App\Models\TickerIndicator;
use App\Models\TickerPriceHistory;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\DB;
use Carbon\Carbon;
use App\Services\Compute\Registry;

/**
 * ============================================================================
 *  FeatureSnapshotBuilder
 * ============================================================================
 *
 * üîß Purpose:
 *   Builds **aggregated, JSON-based feature snapshots** representing the full
 *   analytic "state" of a ticker for each trading day. These snapshots power
 *   TickerWolf‚Äôs machine-learning feature pipelines and AI inference models.
 *
 * üß† Design Overview:
 * ----------------------------------------------------------------------------
 *   A. Inputs:
 *      ‚Ä¢ Core indicators precomputed & stored in `ticker_indicators` (MACD, ATR, ADX, VWAP, ‚Ä¶)
 *      ‚Ä¢ Snapshot-only indicators computed on-the-fly (e.g., Momentum) ‚Äî not persisted to core
 *      ‚Ä¢ Advanced derived analytics via AnalyticsCalculator (Sharpe, Beta, Volatility, Drawdown)
 *
 *   B. Build Flow:
 *      1Ô∏è‚É£ Fetch precomputed indicator rows from `ticker_indicators`
 *      2Ô∏è‚É£ Compute ‚Äúsnapshot-only‚Äù indicators locally (e.g., Momentum) from OHLCV bars
 *      3Ô∏è‚É£ Compute derived analytics via `AnalyticsCalculator`
 *      4Ô∏è‚É£ Merge all per-day metrics ‚Üí complete feature vector
 *      5Ô∏è‚É£ Persist to:
 *          - `ticker_feature_snapshots` (rich JSON blobs)
 *          - `ticker_feature_metrics`   (flat numeric summary table)
 *
 * üí° Why compute some indicators locally here?
 * ----------------------------------------------------------------------------
 *   ‚Ä¢ By design, certain indicators (like Momentum) are **not stored** in
 *     `ticker_indicators` (core layer). They belong to the **snapshot layer**.
 *   ‚Ä¢ Previously this made fields like `momentum_10` appear as `null` in snapshots.
 *   ‚Ä¢ This class now computes those snapshot-only metrics before merging, so the
 *     JSON and flat metrics are complete.
 *
 * ‚úÖ Logging:
 * ----------------------------------------------------------------------------
 *   ‚Ä¢ Start/finish logs
 *   ‚Ä¢ Per-module compute summaries for snapshot-only indicators
 *   ‚Ä¢ Metrics summary write counts
 *
 * ============================================================================
 */
class FeatureSnapshotBuilder
{
    public function __construct(
        protected AnalyticsCalculator $calc
    ) {}

    /**
     * Build and persist (or preview) feature snapshots for a single ticker.
     *
     * @param  int   $tickerId   The ID of the ticker being processed
     * @param  array $range      Date range in ['from' => 'YYYY-MM-DD', 'to' => 'YYYY-MM-DD'] format
     * @param  array $params     Optional runtime parameters (per-indicator overrides)
     * @param  bool  $preview    If true, performs a dry-run (no DB writes)
     * @return array{snapshots:int} Summary of total snapshots written or simulated
     */
    public function buildForTicker(int $tickerId, array $range = [], array $params = [], bool $preview = false): array
    {
        /*
        |--------------------------------------------------------------------------
        | 0Ô∏è‚É£ Resolve policy/config and load ticker
        |--------------------------------------------------------------------------
        */
        $storage  = config('indicators.storage');
        $defaults = config('indicators.defaults');

        /** @var Ticker|null $ticker */
        $ticker = Ticker::find($tickerId);
        if (!$ticker) {
            Log::channel('ingest')->warning("‚ö†Ô∏è FeatureSnapshotBuilder aborted: ticker not found", [
                'ticker_id' => $tickerId,
            ]);
            return ['snapshots' => 0];
        }

        /*
        |--------------------------------------------------------------------------
        | 1Ô∏è‚É£ Define range and initialization
        |--------------------------------------------------------------------------
        */
        $from = $range['from'] ?? null;
        $to   = $range['to'] ?? null;

        Log::channel('ingest')->info("üöÄ Starting FeatureSnapshotBuilder", [
            'ticker_id' => $tickerId,
            'range'     => $range,
            'preview'   => $preview,
        ]);

        /*
        |--------------------------------------------------------------------------
        | 2Ô∏è‚É£ Fetch precomputed core indicator rows (from ticker_indicators)
        |--------------------------------------------------------------------------
        | These are the high-value, stored-daily indicators (MACD, ATR, ADX, VWAP).
        */
        $coreQ = TickerIndicator::query()
            ->where('ticker_id', $tickerId)
            ->where('resolution', '1d');

        if ($from) $coreQ->where('t', '>=', $from);
        if ($to)   $coreQ->where('t', '<=', $to);

        $coreRows = $coreQ->orderBy('t', 'asc')
            ->get(['t', 'indicator', 'value', 'meta']);

        if ($coreRows->isEmpty()) {
            Log::channel('ingest')->warning("‚ö†Ô∏è No core indicator data found for ticker", [
                'ticker_id' => $tickerId,
                'range'     => $range,
            ]);
            return ['snapshots' => 0];
        }

        // Group core rows by date with safe meta decoding
        $grouped = [];
        foreach ($coreRows as $row) {
            $key = Carbon::parse($row->t)->toDateString();

            // Normalize meta field
            $metaValue = $row->meta;
            if (is_array($metaValue)) {
                $meta = $metaValue;
            } elseif (is_string($metaValue) && $metaValue !== '') {
                $meta = json_decode($metaValue, true);
            } else {
                $meta = null;
            }

            $grouped[$key][$row->indicator] = [
                'value' => is_null($row->value) ? null : (float) $row->value,
                'meta'  => $meta,
            ];
        }

        /*
        |--------------------------------------------------------------------------
        | 3Ô∏è‚É£ Compute snapshot-only indicators locally (e.g., Momentum)
        |--------------------------------------------------------------------------
        | We load OHLCV bars once and run only the indicators that are configured
        | to live in the snapshot layer but are *not* part of the core layer.
        |
        | ‚Ä¢ snapshotSet = storage['ticker_feature_snapshots']
        | ‚Ä¢ coreSet     = storage['ticker_indicators']
        | ‚Ä¢ derivedSet  = computed by AnalyticsCalculator: beta, sharpe, volatility, drawdown
        | ‚Ä¢ computeSet  = snapshotSet - coreSet - derivedSet  (e.g., 'momentum')
        */
        $snapshotSet = (array)($storage['ticker_feature_snapshots'] ?? []);
        $coreSet     = (array)($storage['ticker_indicators']        ?? []);
        $derivedSet  = ['beta', 'sharpe', 'volatility', 'drawdown']; // handled by AnalyticsCalculator

        $computeSet  = array_values(array_diff($snapshotSet, $coreSet, $derivedSet));
        if (!empty($computeSet)) {
            // 3a. Load bars (only once)
            $barsQ = TickerPriceHistory::query()
                ->where('ticker_id', $tickerId)
                ->where('resolution', '1d');

            // Extend the "from" window back by a buffer to satisfy lookbacks (e.g., momentum_10)
            // We'll subtract ~90 days as a safe buffer; DB will clamp if not available.
            if ($from) {
                $fromBuf = Carbon::parse($from)->subDays(90)->toDateString();
                $barsQ->where('t', '>=', $fromBuf);
            }
            if ($to) {
                $barsQ->where('t', '<=', $to);
            }

            $bars = $barsQ->orderBy('t', 'asc')
                ->get(['t','o','h','l','c','v','vw'])
                ->map(fn($row) => [
                    't'  => Carbon::parse($row->t)->toDateTimeString(),
                    'o'  => (float) $row->o,
                    'h'  => (float) $row->h,
                    'l'  => (float) $row->l,
                    'c'  => (float) $row->c,
                    'v'  => (float) $row->v,
                    'vw' => (float) $row->vw,
                ])
                ->values()
                ->all();

            if (empty($bars)) {
                Log::channel('ingest')->warning("‚ö†Ô∏è No OHLCV bars found for snapshot-only compute", [
                    'ticker' => $ticker->ticker,
                    'range'  => $range,
                    'set'    => $computeSet,
                ]);
            } else {
                // 3b. Resolve and run the snapshot-only modules
                $modules = Registry::select($computeSet);

                if (empty($modules)) {
                    Log::channel('ingest')->warning("‚ö†Ô∏è No snapshot-only indicator modules resolved", [
                        'ticker' => $ticker->ticker,
                        'set'    => $computeSet,
                    ]);
                } else {
                    foreach ($modules as $module) {
                        // Merge config defaults + runtime overrides
                        $modParams = array_replace_recursive(
                            $defaults[$module->name] ?? [],
                            $params[$module->name]   ?? []
                        );

                        // Normalize 'period' ‚Üí 'window' and 'windows' when appropriate
                        if (isset($modParams['period']) && !isset($modParams['window'])) {
                            $modParams['window'] = $modParams['period'];
                        }
                        if (isset($modParams['window']) && !isset($modParams['windows'])) {
                            $modParams['windows'] = [$modParams['window']];
                        }

                        $rows = $module->compute($bars, $modParams);

                        Log::channel('ingest')->info("üßÆ Snapshot-only module computed", [
                            'ticker' => $ticker->ticker,
                            'module' => $module->name,
                            'rows'   => is_array($rows) ? count($rows) : 0,
                            'params' => $modParams,
                        ]);

                        // Route into the grouped-per-day structure, respecting the user date range
                        foreach ($rows as $r) {
                            $t = isset($r['t']) ? Carbon::parse($r['t'])->toDateString() : null;
                            if (!$t) continue;

                            // Clamp final day to requested window
                            if ($from && $t < $from) continue;
                            if ($to   && $t > $to)   continue;

                            if (!isset($grouped[$t])) {
                                $grouped[$t] = [];
                            }

                            $grouped[$t][$r['indicator']] = [
                                'value' => $r['value'],
                                'meta'  => $r['meta'],
                            ];
                        }
                    }
                }
            }
        }

        /*
        |--------------------------------------------------------------------------
        | 4Ô∏è‚É£ Compute derived analytics (Sharpe, Beta, Volatility, Drawdown, etc.)
        |--------------------------------------------------------------------------
        | The AnalyticsCalculator handles heavier computations. It returns a map:
        |   [ 'YYYY-MM-DD' => ['sharpe_60' => ['value'=>...], 'drawdown' => ...], ... ]
        */
        $derived = $this->calc->computeDerivedAnalytics($tickerId, $from, $to);

        /*
        |--------------------------------------------------------------------------
        | 5Ô∏è‚É£ Merge base + snapshot-only + derived into final snapshots
        |--------------------------------------------------------------------------
        | For each date in the union, merge all metric maps into one.
        */
        $allDates = array_unique(array_merge(array_keys($grouped), array_keys($derived)));
        sort($allDates);

        $rows = [];
        foreach ($allDates as $date) {
            // Only produce snapshots within requested [from, to]
            if ($from && $date < $from) continue;
            if ($to   && $date > $to)   continue;

            $base    = $grouped[$date] ?? [];
            $derivedForDay = $derived[$date] ?? [];

            // Derived entries are already in indicator-keyed form
            $snapshot = $base;
            foreach ($derivedForDay as $k => $payload) {
                $snapshot[$k] = $payload; // ['value'=>..., 'meta'=>...]
            }

            $rows[] = [
                'ticker_id'  => $tickerId,
                't'          => $date,
                'indicators' => json_encode($snapshot, JSON_UNESCAPED_SLASHES),
                'created_at' => now(),
                'updated_at' => now(),
            ];
        }

        /*
        |--------------------------------------------------------------------------
        | 6Ô∏è‚É£ Persist results to the database (or simulate in preview mode)
        |--------------------------------------------------------------------------
        | Writes both JSON snapshots and flattened numeric metrics for fast querying.
        */
        $count = 0;

        if (! $preview) {
            // ‚úÖ Write serialized feature snapshots
            foreach (array_chunk($rows, 1000) as $chunk) {
                DB::table('ticker_feature_snapshots')->upsert(
                    $chunk,
                    ['ticker_id', 't'],
                    ['indicators', 'updated_at']
                );
                $count += count($chunk);
            }

            // ‚úÖ Extract key flat metrics for summary analytics
            // NOTE: We keep parity with your prior schema fields.
            $flatRows = [];
            foreach ($rows as $r) {
                $data = json_decode($r['indicators'], true);

                $flatRows[] = [
                    'ticker_id'     => $tickerId,
                    't'             => $r['t'],
                    'sharpe_60'     => $data['sharpe_60']['value']     ?? null,
                    'volatility_30' => $data['volatility_30']['value'] ?? null,
                    'drawdown'      => $data['drawdown']['value']      ?? null,
                    'beta_60'       => $data['beta_60']['value']       ?? null,
                    'momentum_10'   => $data['momentum_10']['value']   ?? null, // ‚Üê now filled
                    'created_at'    => now(),
                    'updated_at'    => now(),
                ];
            }

            foreach (array_chunk($flatRows, 1000) as $chunk) {
                DB::table('ticker_feature_metrics')->upsert(
                    $chunk,
                    ['ticker_id', 't'],
                    ['sharpe_60', 'volatility_30', 'drawdown', 'beta_60', 'momentum_10', 'updated_at']
                );
            }

            Log::channel('ingest')->info("üìä Metrics summary upserted", [
                'ticker_id' => $tickerId,
                'rows'      => count($flatRows),
            ]);
        } else {
            // üí° Dry-run (preview mode)
            $count = count($rows);
            Log::channel('ingest')->info("üí° Preview mode ‚Äî computed {$count} snapshot(s) for ticker {$tickerId}");
        }

        /*
        |--------------------------------------------------------------------------
        | 7Ô∏è‚É£ Logging summary
        |--------------------------------------------------------------------------
        */
        Log::channel('ingest')->info("‚úÖ Feature snapshots built successfully", [
            'ticker_id' => $tickerId,
            'snapshots' => $count,
            'preview'   => $preview,
        ]);

        return ['snapshots' => $count];
    }
}app/Services/Analytics/CorrelationMatrixService.php


===== FILE: app/Services/Analytics/CorrelationMatrixService.php =====

<?php

namespace App\Services\Analytics;

use App\Models\Ticker;
use App\Models\TickerCorrelation;
use App\Services\Compute\BaseIndicator;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;

/**
 * CorrelationMatrixService
 *
 * Generates inter-ticker rolling correlations across all tickers
 * (or within a specified sector/universe).
 *
 * Usage:
 *   (new CorrelationMatrixService())->computeMatrix(lookbackDays: 90);
 */
class CorrelationMatrixService extends BaseAnalytics
{
    /**
     * Compute pairwise correlations between tickers' daily closes.
     *
     * @param int $lookbackDays How many days of data to use.
     * @param int $window Rolling window for correlation (e.g., 20 days).
     */
    public function computeMatrix(int $lookbackDays = 90, int $window = 20): void
    {
        $tickers = Ticker::where('active', true)->get(['id', 'ticker']);
        $priceData = $this->fetchRecentCloses($tickers->pluck('id')->toArray(), $lookbackDays);

        $asOf = now()->toDateString();
        $totalPairs = 0;

        foreach ($tickers as $i => $a) {
            for ($j = $i + 1; $j < count($tickers); $j++) {
                $b = $tickers[$j];
                $totalPairs++;

                $seriesA = $priceData[$a->id] ?? [];
                $seriesB = $priceData[$b->id] ?? [];

                if (count($seriesA) < $window || count($seriesB) < $window) continue;

                // Compute returns
                $retA = $this->returns($seriesA);
                $retB = $this->returns($seriesB);

                // Align and compute rolling correlation
                $corrSeries = $this->rollingCorrelation($retA, $retB, $window);
                $betaSeries = $this->rollingBeta($retA, $retB, $window);

                $lastIdx = count($corrSeries) - 1;
                $corr = $corrSeries[$lastIdx];
                $beta = $betaSeries[$lastIdx];
                $r2   = $corr !== null ? pow($corr, 2) : null;

                if ($corr === null) continue;

                TickerCorrelation::updateOrCreate(
                    [
                        'ticker_id_a' => $a->id,
                        'ticker_id_b' => $b->id,
                        'as_of_date'  => $asOf,
                    ],
                    [
                        'corr' => $corr,
                        'beta' => $beta,
                        'r2'   => $r2,
                    ]
                );
            }
        }

        Log::channel('ingest')->info("‚úÖ Correlation matrix computed", [
            'as_of' => $asOf,
            'pairs' => $totalPairs,
        ]);
    }

    /**
     * Fetch recent closing prices (simple version for now).
     *
     * @return array<int, array<float>> keyed by ticker_id
     */
    protected function fetchRecentCloses(array $tickerIds, int $lookbackDays): array
    {
        $rows = DB::table('ticker_bars')
            ->whereIn('ticker_id', $tickerIds)
            ->where('t', '>=', now()->subDays($lookbackDays))
            ->orderBy('t')
            ->get(['ticker_id', 'c']);

        $data = [];
        foreach ($rows as $r) {
            $data[$r->ticker_id][] = (float)$r->c;
        }
        return $data;
    }
}
app/Services/Analytics/AnalyticsCalculator.php


===== FILE: app/Services/Analytics/AnalyticsCalculator.php =====

<?php

namespace App\Services\Analytics;

use App\Models\Ticker;
use App\Models\TickerIndicator;
use App\Models\TickerPriceHistory;
use Illuminate\Support\Facades\Log;
use Carbon\Carbon;

/**
 * ============================================================================
 *  AnalyticsCalculator
 * ============================================================================
 *
 * üîß Purpose:
 *   Provides **derived analytics** for each ticker based on historical price data.
 *   These secondary metrics feed long-horizon feature snapshots and ML pipelines.
 *
 * üß† Core Responsibilities:
 * ----------------------------------------------------------------------------
 *   ‚Ä¢ Compute rolling Sharpe ratios
 *   ‚Ä¢ Compute annualized volatility
 *   ‚Ä¢ Compute drawdowns (relative to prior peaks)
 *   ‚Ä¢ Compute beta (vs. benchmark, e.g., SPY)
 *
 * üí° Notes:
 * ----------------------------------------------------------------------------
 *   ‚Ä¢ All computations are performed on daily close prices (`resolution = 1d`)
 *   ‚Ä¢ Outputs are keyed by date for direct merging into feature snapshots
 *   ‚Ä¢ Returns are log-based (ln(Pt / Pt-1)) for stability with small values
 *   ‚Ä¢ Nulls are inserted for periods before the rolling window length
 *
 * ============================================================================
 */
class AnalyticsCalculator
{
    /**
     * Default benchmark symbol (used for beta computation).
     * You can override this in config/analytics.php or per-call if needed.
     */
    protected string $benchmarkTicker = 'SPY';

    /**
     * Compute derived analytics for a ticker across the specified range.
     *
     * @param  int         $tickerId   Target ticker ID
     * @param  string|null $from       Range start date (YYYY-MM-DD)
     * @param  string|null $to         Range end date (YYYY-MM-DD)
     * @return array<string,array<string,mixed>>  Keyed by date ‚Üí metric ‚Üí {value, meta}
     */
    public function computeDerivedAnalytics(int $tickerId, ?string $from, ?string $to): array
    {
        /*
        |--------------------------------------------------------------------------
        | 1Ô∏è‚É£ Load ticker price history
        |--------------------------------------------------------------------------
        */
        $bars = TickerPriceHistory::query()
            ->where('ticker_id', $tickerId)
            ->where('resolution', '1d')
            ->when($from, fn($q) => $q->where('t', '>=', $from))
            ->when($to, fn($q) => $q->where('t', '<=', $to))
            ->orderBy('t', 'asc')
            ->get(['t', 'c'])
            ->map(fn($r) => ['t' => Carbon::parse($r->t)->toDateString(), 'c' => (float) $r->c])
            ->all();

        if (count($bars) < 2) {
            Log::channel('ingest')->warning('‚ö†Ô∏è Insufficient bars for derived analytics', [
                'ticker_id' => $tickerId,
                'bars'      => count($bars),
            ]);
            return [];
        }

        $closes  = array_column($bars, 'c');
        $dates   = array_column($bars, 't');
        $returns = $this->returns($closes);

        /*
        |--------------------------------------------------------------------------
        | 2Ô∏è‚É£ Compute primary derived metrics
        |--------------------------------------------------------------------------
        */
        $sharpe     = $this->rollingSharpe($returns, $dates, 60);
        $volatility = $this->rollingVolatility($returns, $dates, 30);
        $drawdown   = $this->rollingDrawdown($closes, $dates);

        /*
        |--------------------------------------------------------------------------
        | 3Ô∏è‚É£ Compute Beta (vs. benchmark)
        |--------------------------------------------------------------------------
        | Loads the benchmark (SPY) returns and aligns date ranges before computing
        | rolling 60-day beta as Cov(ticker, benchmark) / Var(benchmark).
        */
        $beta = $this->rollingBeta($returns, $dates, $this->benchmarkTicker, 60);

        /*
        |--------------------------------------------------------------------------
        | 4Ô∏è‚É£ Merge all metrics by date
        |--------------------------------------------------------------------------
        */
        $derived = [];
        foreach ($dates as $i => $date) {
            $derived[$date] = [
                'sharpe_60'     => ['value' => $sharpe[$i]     ?? null, 'meta' => null],
                'volatility_30' => ['value' => $volatility[$i] ?? null, 'meta' => null],
                'drawdown'      => ['value' => $drawdown[$i]   ?? null, 'meta' => null],
                'beta_60'       => ['value' => $beta[$i]       ?? null, 'meta' => ['benchmark' => $this->benchmarkTicker]],
            ];
        }

        return $derived;
    }

    // =========================================================================
    // üßÆ Helper Calculations
    // =========================================================================

    /**
     * Compute simple daily log returns.
     */
    protected function returns(array $closes): array
    {
        $r = [];
        for ($i = 1; $i < count($closes); $i++) {
            $prev = $closes[$i - 1];
            $curr = $closes[$i];
            $r[] = $prev > 0 ? log($curr / $prev) : 0;
        }
        return $r;
    }

    /**
     * Rolling Sharpe ratio (annualized).
     */
    protected function rollingSharpe(array $returns, array $dates, int $period): array
    {
        $out = [];
        for ($i = 0; $i < count($returns); $i++) {
            if ($i < $period) { $out[] = null; continue; }
            $slice = array_slice($returns, $i - $period, $period);
            $mean  = array_sum($slice) / $period;
            $std   = $this->stddev($slice);
            $out[] = $std > 0 ? ($mean / $std) * sqrt(252) : null;
        }
        array_unshift($out, null);
        return $out;
    }

    /**
     * Rolling volatility (annualized standard deviation).
     */
    protected function rollingVolatility(array $returns, array $dates, int $period): array
    {
        $out = [];
        for ($i = 0; $i < count($returns); $i++) {
            if ($i < $period) { $out[] = null; continue; }
            $slice = array_slice($returns, $i - $period, $period);
            $out[] = $this->stddev($slice) * sqrt(252);
        }
        array_unshift($out, null);
        return $out;
    }

    /**
     * Rolling drawdown percentage relative to prior peak.
     */
    protected function rollingDrawdown(array $closes, array $dates): array
    {
        $peak = -INF;
        $out = [];
        foreach ($closes as $c) {
            $peak = max($peak, $c);
            $out[] = $peak > 0 ? ($c - $peak) / $peak : 0;
        }
        return $out;
    }

    /**
     * Rolling Beta vs benchmark (default SPY).
     */
    protected function rollingBeta(array $returns, array $dates, string $benchmarkTicker, int $period): array
    {
        /*
        |--------------------------------------------------------------------------
        | üîç 1Ô∏è‚É£ Resolve benchmark ticker_id
        |--------------------------------------------------------------------------
        */
        $benchmarkId = Ticker::where('ticker', $benchmarkTicker)->value('id');
        if (!$benchmarkId) {
            Log::channel('ingest')->warning("‚ö†Ô∏è Benchmark ticker not found for beta computation", [
                'benchmark' => $benchmarkTicker,
            ]);
            return array_fill(0, count($returns), null);
        }

        /*
        |--------------------------------------------------------------------------
        | üî¢ 2Ô∏è‚É£ Load benchmark closes over same range
        |--------------------------------------------------------------------------
        */
        $benchmarkBars = TickerPriceHistory::query()
            ->where('ticker_id', $benchmarkId)
            ->where('resolution', '1d')
            ->whereBetween('t', [min($dates), max($dates)])
            ->orderBy('t', 'asc')
            ->get(['t', 'c'])
            ->mapWithKeys(fn($r) => [Carbon::parse($r->t)->toDateString() => (float) $r->c])
            ->all();

        if (empty($benchmarkBars)) {
            Log::channel('ingest')->warning("‚ö†Ô∏è No benchmark price data available for {$benchmarkTicker}", [
                'benchmark_id' => $benchmarkId,
            ]);
            return array_fill(0, count($returns), null);
        }

        /*
        |--------------------------------------------------------------------------
        | üß≠ 3Ô∏è‚É£ Align benchmark closes to ticker dates (forward-fill missing)
        |--------------------------------------------------------------------------
        */
        $bmCloses = [];
        foreach ($dates as $d) {
            if (isset($benchmarkBars[$d])) {
                $bmCloses[] = $benchmarkBars[$d];
            } else {
                // forward-fill with last known value
                $bmCloses[] = end($bmCloses) ?: reset($benchmarkBars);
            }
        }

        $bmReturns = $this->returns($bmCloses);
        if (count($bmReturns) < 2) {
            Log::channel('ingest')->warning("‚ö†Ô∏è Insufficient benchmark returns for beta computation", [
                'benchmark' => $benchmarkTicker,
            ]);
            return array_fill(0, count($returns), null);
        }

        /*
        |--------------------------------------------------------------------------
        | üìä 4Ô∏è‚É£ Compute rolling beta
        |--------------------------------------------------------------------------
        */
        $out = [];
        for ($i = 0; $i < count($returns); $i++) {
            if ($i < $period || $i >= count($bmReturns)) {
                $out[] = null;
                continue;
            }
            $sliceA = array_slice($returns, $i - $period, $period);
            $sliceB = array_slice($bmReturns, $i - $period, $period);
            $cov = $this->covariance($sliceA, $sliceB);
            $var = $this->variance($sliceB);
            $out[] = ($var > 0) ? $cov / $var : null;
        }

        array_unshift($out, null);
        return $out;
    }

    // =========================================================================
    // üìä Statistical Helpers
    // =========================================================================

    protected function stddev(array $values): float
    {
        $n = count($values);
        if ($n < 2) return 0.0;
        $mean = array_sum($values) / $n;
        $sumSq = 0.0;
        foreach ($values as $v) $sumSq += pow($v - $mean, 2);
        return sqrt($sumSq / ($n - 1));
    }

    protected function variance(array $values): float
    {
        $std = $this->stddev($values);
        return $std ** 2;
    }

    protected function covariance(array $x, array $y): float
    {
        $n = min(count($x), count($y));
        if ($n < 2) return 0.0;
        $meanX = array_sum($x) / $n;
        $meanY = array_sum($y) / $n;
        $cov = 0.0;
        for ($i = 0; $i < $n; $i++) {
            $cov += ($x[$i] - $meanX) * ($y[$i] - $meanY);
        }
        return $cov / ($n - 1);
    }
}
[EOF: app/Services]
